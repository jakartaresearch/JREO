<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>earthvision.datasets API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>earthvision.datasets</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .drone_deploy import DroneDeploy
from .aerialcactus import AerialCactus
from .resisc45 import RESISC45
from .ucmercedland import UCMercedLand
from .eurosat import EuroSat
from .l8sparcs import L8SPARCS
from .deepsat import DeepSat
from .landcover import LandCover
from .cowc import COWC
from .l7irish import L7Irish
from .sentinel2cloud import Sentinel2Cloud
from .spacenet7 import SpaceNet7
from .xview import XView
from .cloud38 import Cloud38
from .so2sat import So2Sat
from .l8biome import L8Biome


__all__ = [
    &#34;DroneDeploy&#34;,
    &#34;AerialCactus&#34;,
    &#34;RESISC45&#34;,
    &#34;UCMercedLand&#34;,
    &#34;EuroSat&#34;,
    &#34;L8SPARCS&#34;,
    &#34;DeepSat&#34;,
    &#34;LandCover&#34;,
    &#34;COWC&#34;,
    &#34;L7Irish&#34;,
    &#34;Sentinel2Cloud&#34;,
    &#34;SpaceNet7&#34;,
    &#34;XView&#34;,
    &#34;Cloud38&#34;,
    &#34;So2Sat&#34;,
    &#34;L8Biome&#34;,
]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="earthvision.datasets.aerialcactus" href="aerialcactus.html">earthvision.datasets.aerialcactus</a></code></dt>
<dd>
<div class="desc"><p>Aerial Cactus Dataset from Kaggle.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.cloud38" href="cloud38.html">earthvision.datasets.cloud38</a></code></dt>
<dd>
<div class="desc"><p>38-Cloud: A Cloud Segmentation Dataset.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.cowc" href="cowc.html">earthvision.datasets.cowc</a></code></dt>
<dd>
<div class="desc"><p>Cars Overhead with Context Dataset.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.deepsat" href="deepsat.html">earthvision.datasets.deepsat</a></code></dt>
<dd>
<div class="desc"><p>Deepsat Dataset - Scene Classification.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.drone_deploy" href="drone_deploy.html">earthvision.datasets.drone_deploy</a></code></dt>
<dd>
<div class="desc"><p>Drone Deploy Dataset - Semantic Segmentation.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.eurosat" href="eurosat.html">earthvision.datasets.eurosat</a></code></dt>
<dd>
<div class="desc"><p>EuroSat Land Cover Categories Dataset.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.l7irish" href="l7irish.html">earthvision.datasets.l7irish</a></code></dt>
<dd>
<div class="desc"><p>Landsat 7 Irish Cloud Dataset.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.l8biome" href="l8biome.html">earthvision.datasets.l8biome</a></code></dt>
<dd>
<div class="desc"><p>L8 Biome Cloud Cover Dataset.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.l8sparcs" href="l8sparcs.html">earthvision.datasets.l8sparcs</a></code></dt>
<dd>
<div class="desc"><p>Landsat 8 SPARCS Cloud Dataset.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.landcover" href="landcover.html">earthvision.datasets.landcover</a></code></dt>
<dd>
<div class="desc"><p>The LandCover.ai (Land Cover from Aerial Imagery) Dataset.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.resisc45" href="resisc45.html">earthvision.datasets.resisc45</a></code></dt>
<dd>
<div class="desc"><p>RESISC45 Dataset.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.sentinel2cloud" href="sentinel2cloud.html">earthvision.datasets.sentinel2cloud</a></code></dt>
<dd>
<div class="desc"><p>Sentinel-2 Cloud Mask Catalogue Dataset.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.so2sat" href="so2sat.html">earthvision.datasets.so2sat</a></code></dt>
<dd>
<div class="desc"><p>So2Sat Dataset to Predict Local Climate Zone (LCZ).</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.spacenet7" href="spacenet7.html">earthvision.datasets.spacenet7</a></code></dt>
<dd>
<div class="desc"><p>SpaceNet 7 Dataset: Multi-Temporal Urban Development Challenge - Instance Segmentation.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.spacenet7_utils" href="spacenet7_utils.html">earthvision.datasets.spacenet7_utils</a></code></dt>
<dd>
<div class="desc"><p>Script from:
- <a href="https://github.com/CosmiQ/solaris">https://github.com/CosmiQ/solaris</a>
- <a href="https://github.com/avanetten/CosmiQ_SN7_Baseline/blob/master/src/sn7_baseline_prep_funcs.py">https://github.com/avanetten/CosmiQ_SN7_Baseline/blob/master/src/sn7_baseline_prep_funcs.py</a></p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.ucmercedland" href="ucmercedland.html">earthvision.datasets.ucmercedland</a></code></dt>
<dd>
<div class="desc"><p>UC Merced Land Use Dataset.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.utils" href="utils.html">earthvision.datasets.utils</a></code></dt>
<dd>
<div class="desc"><p>Utility functions.</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.vision" href="vision.html">earthvision.datasets.vision</a></code></dt>
<dd>
<div class="desc"><p>Vision Dataset from torchvision/datasets/vision.py</p></div>
</dd>
<dt><code class="name"><a title="earthvision.datasets.xview" href="xview.html">earthvision.datasets.xview</a></code></dt>
<dd>
<div class="desc"><p>Dataset from DIUx xView 2018 Detection Challenge.</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="earthvision.datasets.AerialCactus"><code class="flex name class">
<span>class <span class="ident">AerialCactus</span></span>
<span>(</span><span>root: str, train: bool = True, transform=Compose(
Resize(size=(32, 32), interpolation=bilinear, max_size=None, antialias=None)
ToTensor()
), target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Aerial Cactus Dataset.</p>
<p><a href="https://www.kaggle.com/c/aerial-cactus-identification">https://www.kaggle.com/c/aerial-cactus-identification</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>train</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, creates dataset from training set, otherwise
creates from validation set.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AerialCactus(VisionDataset):
    &#34;&#34;&#34;Aerial Cactus Dataset.
    
    &lt;https://www.kaggle.com/c/aerial-cactus-identification&gt;

    Args:
        root (string): Root directory of dataset.
        train (bool, optional): If True, creates dataset from training set, otherwise
            creates from validation set.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;https://storage.googleapis.com/ossjr&#34;
    resources = &#34;cactus-aerial-photos.zip&#34;

    def __init__(
        self,
        root: str,
        train: bool = True,
        transform=Compose([Resize((32, 32)), ToTensor()]),
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(AerialCactus, self).__init__(
            root, transform=transform, target_transform=target_transform
        )

        self.root = root
        self.data_mode = &#34;training_set&#34; if train else &#34;validation_set&#34;

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        self.img_labels = self.get_path_and_label()

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, target) where target is index of the target class.
        &#34;&#34;&#34;
        img_path = self.img_labels.iloc[idx, 0]
        img = np.array(_load_img(img_path))
        target = self.img_labels.iloc[idx, 1]

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            target = Image.fromarray(target)
            target = self.target_transform(target)
        return img, target

    def __len__(self) -&gt; int:
        return len(self.img_labels)

    def get_path_and_label(self):
        &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label.&#34;&#34;&#34;
        classes = {&#34;cactus&#34;: 1, &#34;no_cactus&#34;: 0}
        image_path, label = [], []

        for cat, enc in classes.items():
            cat_path = os.path.join(
                self.root, &#34;cactus-aerial-photos&#34;, self.data_mode, self.data_mode, cat
            )
            cat_image = [os.path.join(cat_path, path) for path in os.listdir(cat_path)]
            cat_label = [enc] * len(cat_image)
            image_path += cat_image
            label += cat_label
        df = pd.DataFrame({&#34;image&#34;: image_path, &#34;label&#34;: label})

        return df

    def _check_exists(self):
        self.train_path = os.path.join(
            self.root, &#34;cactus-aerial-photos&#34;, &#34;training_set&#34;, &#34;training_set&#34;
        )
        self.valid_path = os.path.join(
            self.root, &#34;cactus-aerial-photos&#34;, &#34;validation_set&#34;, &#34;validation_set&#34;
        )

        folder_status = []
        for path in [self.train_path, self.valid_path]:
            for target in [&#34;cactus&#34;, &#34;no_cactus&#34;]:
                folder_status.append(os.path.exists(os.path.join(path, target)))

        return all(folder_status)

    def download(self) -&gt; None:
        &#34;&#34;&#34;Download and extract file.&#34;&#34;&#34;
        os.makedirs(self.root, exist_ok=True)

        file_url = posixpath.join(self.mirrors, self.resources)
        _urlretrieve(file_url, os.path.join(self.root, self.resources))

    def extract_file(self) -&gt; None:
        &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;
        path_destination = os.path.join(self.root, &#34;cactus-aerial-photos&#34;)
        shutil.unpack_archive(os.path.join(self.root, self.resources), path_destination)
        os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.AerialCactus.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.AerialCactus.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.AerialCactus.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.AerialCactus.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download and extract file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;Download and extract file.&#34;&#34;&#34;
    os.makedirs(self.root, exist_ok=True)

    file_url = posixpath.join(self.mirrors, self.resources)
    _urlretrieve(file_url, os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.AerialCactus.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Extract file from compressed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self) -&gt; None:
    &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;
    path_destination = os.path.join(self.root, &#34;cactus-aerial-photos&#34;)
    shutil.unpack_archive(os.path.join(self.root, self.resources), path_destination)
    os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.AerialCactus.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dataframe type consist of image path and corresponding label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label.&#34;&#34;&#34;
    classes = {&#34;cactus&#34;: 1, &#34;no_cactus&#34;: 0}
    image_path, label = [], []

    for cat, enc in classes.items():
        cat_path = os.path.join(
            self.root, &#34;cactus-aerial-photos&#34;, self.data_mode, self.data_mode, cat
        )
        cat_image = [os.path.join(cat_path, path) for path in os.listdir(cat_path)]
        cat_label = [enc] * len(cat_image)
        image_path += cat_image
        label += cat_label
    df = pd.DataFrame({&#34;image&#34;: image_path, &#34;label&#34;: label})

    return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.COWC"><code class="flex name class">
<span>class <span class="ident">COWC</span></span>
<span>(</span><span>root: str, train: bool = True, task_mode: str = 'counting', transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Cars Overhead with Context.</p>
<p><a href="https://gdo152.llnl.gov/cowc/">https://gdo152.llnl.gov/cowc/</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>train</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, creates dataset from training set, otherwise
creates from test set.</dd>
<dt><strong><code>task_mode</code></strong> :&ensp;<code>string</code></dt>
<dd>There is 2 task mode i.e. 'counting' and 'detection'. Default value is 'counting'.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class COWC(VisionDataset):
    &#34;&#34;&#34;Cars Overhead with Context.
    
    https://gdo152.llnl.gov/cowc/

    Args:
        root (string): Root directory of dataset.
        train (bool, optional): If True, creates dataset from training set, otherwise
            creates from test set.
        task_mode (string): There is 2 task mode i.e. &#39;counting&#39; and &#39;detection&#39;. Default value is &#39;counting&#39;.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;https://gdo152.llnl.gov/cowc/download&#34;
    resources = &#34;cowc-everything.txz&#34;

    def __init__(
        self,
        root: str,
        train: bool = True,
        task_mode: str = &#34;counting&#34;,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(COWC, self).__init__(root, transform=transform, target_transform=target_transform)

        self.root = root
        self.train = train
        self.task_mode = task_mode

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        if self.task_mode == &#34;counting&#34;:
            self.task_path = os.path.join(self.root, &#34;cowc/datasets/patch_sets/counting&#34;)
            self.file_mapping = file_mapping_counting
        elif self.task_mode == &#34;detection&#34;:
            self.task_path = os.path.join(self.root, &#34;cowc/datasets/patch_sets/detection&#34;)
            self.file_mapping = file_mapping_detection
        else:
            raise ValueError(&#34;task_mode not recognized.&#34;)

        for filename, compressed in self.file_mapping.items():
            if not self._check_exists_subfile(filename):
                self.extract_subfile(filename, compressed)

        self.img_labels = self.get_path_and_label()

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, target) where target is index of the target class.
        &#34;&#34;&#34;
        img_path = self.img_labels.iloc[idx, 0]
        target = self.img_labels.iloc[idx, 1]
        folder = img_path.split(&#34;/&#34;, 1)[0]
        img_path = os.path.join(self.task_path, folder, img_path)
        img = np.array(_load_img(img_path))

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            target = Image.fromarray(target)
            target = self.target_transform(target)
        return img, target

    def __len__(self) -&gt; int:
        return len(self.img_labels)

    def get_path_and_label(self):
        &#34;&#34;&#34;Return dataframe type consist of image path
        and corresponding label.&#34;&#34;&#34;

        if self.task_mode == &#34;counting&#34;:
            if self.train:
                label_name = &#34;COWC_train_list_64_class.txt.bz2&#34;
            else:
                label_name = &#34;COWC_test_list_64_class.txt.bz2&#34;

        elif self.task_mode == &#34;detection&#34;:
            if self.train:
                label_name = &#34;COWC_train_list_detection.txt.bz2&#34;
            else:
                label_name = &#34;COWC_test_list_detection.txt.bz2&#34;

        else:
            raise ValueError(&#34;task_mode not recognized.&#34;)

        label_path = os.path.join(self.task_path, label_name)
        df = pd.read_csv(label_path, sep=&#34; &#34;, header=None)

        return df

    def _check_exists_subfile(self, filename):
        path_to_check = os.path.join(self.task_path, filename)
        return os.path.exists(path_to_check)

    def extract_subfile(self, filename, compressed):
        comp_path = os.path.join(self.task_path, compressed)
        file_path = os.path.join(self.task_path, filename)
        tar = tarfile.open(comp_path)
        tar.extractall(file_path)
        tar.close()

    def _check_exists(self):
        return os.path.exists(os.path.join(self.root, &#34;cowc&#34;))

    def download(self) -&gt; None:
        &#34;&#34;&#34;download file.&#34;&#34;&#34;
        file_url = posixpath.join(self.mirrors, self.resources)
        _urlretrieve(file_url, os.path.join(self.root, self.resources))

    def extract_file(self) -&gt; None:
        &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;
        shutil.unpack_archive(os.path.join(self.root, self.resources), self.root)
        os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.COWC.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.COWC.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.COWC.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.COWC.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>download file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;download file.&#34;&#34;&#34;
    file_url = posixpath.join(self.mirrors, self.resources)
    _urlretrieve(file_url, os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.COWC.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Extract file from compressed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self) -&gt; None:
    &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;
    shutil.unpack_archive(os.path.join(self.root, self.resources), self.root)
    os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.COWC.extract_subfile"><code class="name flex">
<span>def <span class="ident">extract_subfile</span></span>(<span>self, filename, compressed)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_subfile(self, filename, compressed):
    comp_path = os.path.join(self.task_path, compressed)
    file_path = os.path.join(self.task_path, filename)
    tar = tarfile.open(comp_path)
    tar.extractall(file_path)
    tar.close()</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.COWC.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dataframe type consist of image path
and corresponding label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Return dataframe type consist of image path
    and corresponding label.&#34;&#34;&#34;

    if self.task_mode == &#34;counting&#34;:
        if self.train:
            label_name = &#34;COWC_train_list_64_class.txt.bz2&#34;
        else:
            label_name = &#34;COWC_test_list_64_class.txt.bz2&#34;

    elif self.task_mode == &#34;detection&#34;:
        if self.train:
            label_name = &#34;COWC_train_list_detection.txt.bz2&#34;
        else:
            label_name = &#34;COWC_test_list_detection.txt.bz2&#34;

    else:
        raise ValueError(&#34;task_mode not recognized.&#34;)

    label_path = os.path.join(self.task_path, label_name)
    df = pd.read_csv(label_path, sep=&#34; &#34;, header=None)

    return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.Cloud38"><code class="flex name class">
<span>class <span class="ident">Cloud38</span></span>
<span>(</span><span>root: str, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Cloud 38 Dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cloud38(VisionDataset):
    &#34;&#34;&#34;Cloud 38 Dataset.

    Args:
        root (string): Root directory of dataset.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;http://vault.sfu.ca/index.php/s/pymNqYF09JkM8Bp/download&#34;
    resources = &#34;38cloud.zip&#34;

    def __init__(
        self,
        root: str,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(Cloud38, self).__init__(root, transform=transform, target_transform=target_transform)

        self.root = root
        self.data_path = os.path.join(self.root, &#34;38cloud&#34;)
        self.base_path = Path(os.path.join(self.data_path, &#34;38-Cloud_training&#34;))

        if not os.path.exists(self.root):
            os.makedirs(self.root)

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        self.file_validator()
        self.labels = self.get_path()
        print(&#34;Done.&#34;)

    def file_validator(self):
        if not (self.base_path / &#34;train_rgb&#34;).exists():
            (self.base_path / &#34;train_rgb&#34;).mkdir()

        if not (self.base_path / &#34;labels&#34;).exists():
            (self.base_path / &#34;labels&#34;).mkdir()

        for red_patch in (self.base_path / &#34;train_red&#34;).iterdir():
            self.create_rgb_pil(red_patch)

        for gt_patch in (self.base_path / &#34;train_gt&#34;).iterdir():
            self.convert_tif_png(gt_patch, self.base_path / &#34;labels&#34;)

    def get_path(self):
        label = []
        path_label = os.path.join(self.base_path, &#34;labels&#34;)
        path_gt = os.path.join(self.base_path, &#34;train_gt&#34;)
        label_listing = [os.path.join(path_label, i) for i in os.listdir(path_label)]
        gt_listing = [os.path.join(path_gt, i) for i in os.listdir(path_gt)]
        return pd.DataFrame({&#34;GT&#34;: gt_listing, &#34;Label&#34;: label_listing})

    def create_rgb_pil(self, red_filename: Path):
        &#34;&#34;&#34;Combining three bands to RGB format&#34;&#34;&#34;
        self.red_filename = str(red_filename)
        green_fn = self.red_filename.replace(&#34;red&#34;, &#34;green&#34;)
        blue_fn = self.red_filename.replace(&#34;red&#34;, &#34;blue&#34;)
        rgb_fn = self.red_filename.replace(&#34;red&#34;, &#34;rgb&#34;).replace(&#34;.TIF&#34;, &#34;.png&#34;)

        array_red = np.array(Image.open(self.red_filename))
        array_green = np.array(Image.open(green_fn))
        array_blue = np.array(Image.open(blue_fn))

        array_rgb = np.stack([array_red, array_green, array_blue], axis=2)
        array_rgb = array_rgb / np.iinfo(array_rgb.dtype).max

        rgb = Image.fromarray((256 * array_rgb).astype(np.uint8), &#34;RGB&#34;)
        rgb.save(rgb_fn)
        return rgb

    def convert_tif_png(self, tif_file: Path, out_folder: Path):
        &#34;&#34;&#34;Converting TIF file to PNG format&#34;&#34;&#34;
        self.tif_file = tif_file
        self.out_folder = out_folder
        array_tif = np.array(Image.open(self.tif_file))
        im = Image.fromarray(np.where(array_tif == 255, 1, 0))
        im.save(self.out_folder / self.tif_file.with_suffix(&#34;.png&#34;).name)
        return im

    def __len__(self) -&gt; int:
        return len(self.img_labels)

    def download(self) -&gt; None:
        &#34;&#34;&#34;download and extract file.&#34;&#34;&#34;
        _urlretrieve(self.mirrors, os.path.join(self.root, self.resources))

    def _check_exists(self):
        &#34;&#34;&#34;Check file has been download or not&#34;&#34;&#34;
        folders = [
            &#34;38-Cloud_95-Cloud_Test_Metadata_Files&#34;,
            &#34;38-Cloud_test&#34;,
            &#34;38-Cloud_training&#34;,
            &#34;38-Cloud_Training_Metadata_Files&#34;,
        ]

        status = [
            os.path.exists(os.path.join(self.data_path, folder_pth)) for folder_pth in folders
        ]
        return all(status)

    def extract_file(self):
        &#34;&#34;&#34;Extract file from the compressed&#34;&#34;&#34;
        print(&#34;Extracting...&#34;)
        shutil.unpack_archive(os.path.join(self.root, self.resources), self.root)
        os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.Cloud38.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.Cloud38.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.Cloud38.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.Cloud38.convert_tif_png"><code class="name flex">
<span>def <span class="ident">convert_tif_png</span></span>(<span>self, tif_file: pathlib.Path, out_folder: pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Converting TIF file to PNG format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def convert_tif_png(self, tif_file: Path, out_folder: Path):
    &#34;&#34;&#34;Converting TIF file to PNG format&#34;&#34;&#34;
    self.tif_file = tif_file
    self.out_folder = out_folder
    array_tif = np.array(Image.open(self.tif_file))
    im = Image.fromarray(np.where(array_tif == 255, 1, 0))
    im.save(self.out_folder / self.tif_file.with_suffix(&#34;.png&#34;).name)
    return im</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.Cloud38.create_rgb_pil"><code class="name flex">
<span>def <span class="ident">create_rgb_pil</span></span>(<span>self, red_filename: pathlib.Path)</span>
</code></dt>
<dd>
<div class="desc"><p>Combining three bands to RGB format</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_rgb_pil(self, red_filename: Path):
    &#34;&#34;&#34;Combining three bands to RGB format&#34;&#34;&#34;
    self.red_filename = str(red_filename)
    green_fn = self.red_filename.replace(&#34;red&#34;, &#34;green&#34;)
    blue_fn = self.red_filename.replace(&#34;red&#34;, &#34;blue&#34;)
    rgb_fn = self.red_filename.replace(&#34;red&#34;, &#34;rgb&#34;).replace(&#34;.TIF&#34;, &#34;.png&#34;)

    array_red = np.array(Image.open(self.red_filename))
    array_green = np.array(Image.open(green_fn))
    array_blue = np.array(Image.open(blue_fn))

    array_rgb = np.stack([array_red, array_green, array_blue], axis=2)
    array_rgb = array_rgb / np.iinfo(array_rgb.dtype).max

    rgb = Image.fromarray((256 * array_rgb).astype(np.uint8), &#34;RGB&#34;)
    rgb.save(rgb_fn)
    return rgb</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.Cloud38.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>download and extract file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;download and extract file.&#34;&#34;&#34;
    _urlretrieve(self.mirrors, os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.Cloud38.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract file from the compressed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self):
    &#34;&#34;&#34;Extract file from the compressed&#34;&#34;&#34;
    print(&#34;Extracting...&#34;)
    shutil.unpack_archive(os.path.join(self.root, self.resources), self.root)
    os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.Cloud38.file_validator"><code class="name flex">
<span>def <span class="ident">file_validator</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_validator(self):
    if not (self.base_path / &#34;train_rgb&#34;).exists():
        (self.base_path / &#34;train_rgb&#34;).mkdir()

    if not (self.base_path / &#34;labels&#34;).exists():
        (self.base_path / &#34;labels&#34;).mkdir()

    for red_patch in (self.base_path / &#34;train_red&#34;).iterdir():
        self.create_rgb_pil(red_patch)

    for gt_patch in (self.base_path / &#34;train_gt&#34;).iterdir():
        self.convert_tif_png(gt_patch, self.base_path / &#34;labels&#34;)</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.Cloud38.get_path"><code class="name flex">
<span>def <span class="ident">get_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path(self):
    label = []
    path_label = os.path.join(self.base_path, &#34;labels&#34;)
    path_gt = os.path.join(self.base_path, &#34;train_gt&#34;)
    label_listing = [os.path.join(path_label, i) for i in os.listdir(path_label)]
    gt_listing = [os.path.join(path_gt, i) for i in os.listdir(path_gt)]
    return pd.DataFrame({&#34;GT&#34;: gt_listing, &#34;Label&#34;: label_listing})</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.DeepSat"><code class="flex name class">
<span>class <span class="ident">DeepSat</span></span>
<span>(</span><span>root: str, dataset_type='SAT-4', train: bool = True, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>DeepSat Dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>dataset_type</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Choose dataset type ['SAT-4', 'SAT-6'].</dd>
<dt><strong><code>train</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, creates dataset from training set, otherwise
creates from test set.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DeepSat(VisionDataset):
    &#34;&#34;&#34;DeepSat Dataset.

    Args:
        root (string): Root directory of dataset.
        dataset_type (string, optional): Choose dataset type [&#39;SAT-4&#39;, &#39;SAT-6&#39;].
        train (bool, optional): If True, creates dataset from training set, otherwise
            creates from test set.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    resources = {
        &#34;SAT-4_and_SAT-6_datasets&#34;: &#34;https://drive.google.com/uc?id=0B0Fef71_vt3PUkZ4YVZ5WWNvZWs&amp;export=download&#34;
    }
    dataset_types = [&#34;SAT-4&#34;, &#34;SAT-6&#34;]

    def __init__(
        self,
        root: str,
        dataset_type=&#34;SAT-4&#34;,
        train: bool = True,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(DeepSat, self).__init__(root, transform=transform, target_transform=target_transform)

        self.root = root
        self.dataset_type = dataset_type
        self.train = train
        self.folder_pth = os.path.join(self.root, list(self.resources.keys())[0])
        self.filename = list(self.resources.keys())[0] + &#34;.tar.gz&#34;

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()

        dataset = self.load_dataset()
        self.choose_data_mode(dataset)

    def download(self) -&gt; None:
        &#34;&#34;&#34;Download dataset and extract it&#34;&#34;&#34;

        self.root = os.path.expanduser(self.root)
        print(&#34;Download dataset...&#34;)

        gdown.download(
            self.resources[&#34;SAT-4_and_SAT-6_datasets&#34;],
            os.path.join(self.root, self.filename),
            quiet=False,
        )

        if os.path.exists(self.folder_pth):
            print(f&#34;file {self.folder_pth} already exists&#34;)
        else:
            os.mkdir(self.folder_pth)
            print(f&#34;Extracting file {self.filename}&#34;)
            os.system(f&#34;tar -xvf {os.path.join(self.root, self.filename)} -C {self.folder_pth}&#34;)
            os.system(f&#34;mv {self.folder_pth} {self.root}&#34;)
            print(&#34;Extracting file success !&#34;)

    def _check_exists(self) -&gt; bool:
        if self.dataset_type not in self.dataset_types:
            print(f&#34;Unknown dataset {self.dataset_type}&#34;)
            print(f&#34;Available dataset : {self.dataset_types}&#34;)
            sys.exit(0)

        if os.path.exists(self.filename):
            return True
        else:
            return False

    def load_dataset(self):
        filename = {&#34;SAT-4&#34;: &#34;sat-4-full.mat&#34;, &#34;SAT-6&#34;: &#34;sat-6-full.mat&#34;}
        dataset = sio.loadmat(os.path.join(self.folder_pth, filename[self.dataset_type]))
        return dataset

    def choose_data_mode(self, dataset):
        if self.train:
            x_type, y_type = &#34;train_x&#34;, &#34;train_y&#34;
        else:
            x_type, y_type = &#34;test_x&#34;, &#34;test_y&#34;

        self.x, self.y = dataset[x_type], dataset[y_type]
        self.annot = dataset[&#34;annotations&#34;]

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, target) where target is index of the target class.
        &#34;&#34;&#34;
        img = self.x[:, :, :, idx]
        target = self.y[:, idx]

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            target = Image.fromarray(target)
            target = self.target_transform(target)
        return img, target

    def __len__(self) -&gt; int:
        return self.x.shape[3]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.DeepSat.dataset_types"><code class="name">var <span class="ident">dataset_types</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.DeepSat.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.DeepSat.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.DeepSat.choose_data_mode"><code class="name flex">
<span>def <span class="ident">choose_data_mode</span></span>(<span>self, dataset)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def choose_data_mode(self, dataset):
    if self.train:
        x_type, y_type = &#34;train_x&#34;, &#34;train_y&#34;
    else:
        x_type, y_type = &#34;test_x&#34;, &#34;test_y&#34;

    self.x, self.y = dataset[x_type], dataset[y_type]
    self.annot = dataset[&#34;annotations&#34;]</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.DeepSat.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download dataset and extract it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;Download dataset and extract it&#34;&#34;&#34;

    self.root = os.path.expanduser(self.root)
    print(&#34;Download dataset...&#34;)

    gdown.download(
        self.resources[&#34;SAT-4_and_SAT-6_datasets&#34;],
        os.path.join(self.root, self.filename),
        quiet=False,
    )

    if os.path.exists(self.folder_pth):
        print(f&#34;file {self.folder_pth} already exists&#34;)
    else:
        os.mkdir(self.folder_pth)
        print(f&#34;Extracting file {self.filename}&#34;)
        os.system(f&#34;tar -xvf {os.path.join(self.root, self.filename)} -C {self.folder_pth}&#34;)
        os.system(f&#34;mv {self.folder_pth} {self.root}&#34;)
        print(&#34;Extracting file success !&#34;)</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.DeepSat.load_dataset"><code class="name flex">
<span>def <span class="ident">load_dataset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_dataset(self):
    filename = {&#34;SAT-4&#34;: &#34;sat-4-full.mat&#34;, &#34;SAT-6&#34;: &#34;sat-6-full.mat&#34;}
    dataset = sio.loadmat(os.path.join(self.folder_pth, filename[self.dataset_type]))
    return dataset</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.DroneDeploy"><code class="flex name class">
<span>class <span class="ident">DroneDeploy</span></span>
<span>(</span><span>root: str, dataset_type='dataset-sample', data_mode: int = 0, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Drone Deploy Semantic Dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>dataset_type</code></strong> :&ensp;<code>string</code>, optional</dt>
<dd>Choose dataset type.</dd>
<dt><strong><code>data_mode</code></strong> :&ensp;<code>int</code></dt>
<dd>0 for train data, 1 for validation data, and 2 for testing data</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DroneDeploy(VisionDataset):
    &#34;&#34;&#34;Drone Deploy Semantic Dataset.

    Args:
        root (string): Root directory of dataset.
        dataset_type (string, optional): Choose dataset type.
        data_mode (int): 0 for train data, 1 for validation data, and 2 for testing data
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.

    &#34;&#34;&#34;

    resources = {
        &#34;dataset-sample&#34;: &#34;https://dl.dropboxusercontent.com/s/h8a8kev0rktf4kq/dataset-sample.tar.gz?dl=0&#34;,
        &#34;dataset-medium&#34;: &#34;https://dl.dropboxusercontent.com/s/r0dj9mhyv4bgbme/dataset-medium.tar.gz?dl=0&#34;,
    }

    def __init__(
        self,
        root: str,
        dataset_type=&#34;dataset-sample&#34;,
        data_mode: int = 0,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(DroneDeploy, self).__init__(
            root, transform=transform, target_transform=target_transform
        )

        self.root = root
        self.dataset_type = dataset_type
        self.filename = f&#34;{dataset_type}.tar.gz&#34;
        self.filepath = os.path.join(self.root, self.filename)
        self.data_mode = data_mode
        self.label_path = f&#34;{dataset_type}/label-chips&#34;
        self.image_path = f&#34;{dataset_type}/image-chips&#34;

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()

        self.load_dataset()

    def download(self) -&gt; None:
        &#34;&#34;&#34;Download a dataset, extract it and create the tiles.&#34;&#34;&#34;
        print(f&#39;Downloading &#34;{self.dataset_type}&#34;&#39;)
        self.root = os.path.expanduser(self.root)
        fpath = os.path.join(self.root, self.filename)
        _urlretrieve(self.resources[self.dataset_type], fpath)

        if not os.path.exists(os.path.join(self.root, self.dataset_type)):
            print(f&#39;Extracting &#34;{self.filepath}&#34;&#39;)
            os.system(f&#34;tar -xvf {self.filepath}&#34;)
            os.system(f&#34;mv {self.dataset_type} {self.root}&#34;)
        else:
            print(f&#39;Folder &#34;{self.dataset_type}&#34; already exists.&#39;)

        image_chips = f&#34;{self.dataset_type}/image-chips&#34;
        label_chips = f&#34;{self.dataset_type}/label-chips&#34;

        if not os.path.exists(image_chips):
            os.mkdir(os.path.join(self.root, image_chips))
        if not os.path.exists(label_chips):
            os.mkdir(os.path.join(self.root, label_chips))

        run(os.path.join(self.root, self.dataset_type))

    def _check_exists(self) -&gt; bool:
        if self.dataset_type not in self.resources.keys():
            print(f&#34;Unknown dataset {self.dataset_type}&#34;)
            print(f&#34;Available dataset : {self.resources.keys()}&#34;)
            sys.exit(0)

        if os.path.exists(self.filepath):
            return True
        else:
            return False

    def load_dataset(self):
        if self.data_mode == 0:
            list_chip = &#34;train.txt&#34;
        elif self.data_mode == 1:
            list_chip = &#34;valid.txt&#34;
        elif self.data_mode == 2:
            list_chip = &#34;test.txt&#34;

        files = [
            f&#34;{os.path.join(self.root, self.dataset_type)}/image-chips/{fname}&#34;
            for fname in load_lines(os.path.join(self.root, self.dataset_type, list_chip))
        ]
        self.image_files = files

    def __getitem__(self, idx) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, target) where target is index of the target class.
        &#34;&#34;&#34;
        image_file = self.image_files[idx]
        label_file = image_file.replace(self.image_path, self.label_path)

        img = np.array(load_img(image_file))
        target = mask_to_classes(load_img(label_file))
        target = np.array(target)

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            target = Image.fromarray(target)
            target = self.target_transform(target)
        return img, target

    def __len__(self) -&gt; int:
        return len(self.image_files)

    def on_epoch_end(self):
        random.shuffle(self.image_files)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.DroneDeploy.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.DroneDeploy.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.DroneDeploy.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download a dataset, extract it and create the tiles.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;Download a dataset, extract it and create the tiles.&#34;&#34;&#34;
    print(f&#39;Downloading &#34;{self.dataset_type}&#34;&#39;)
    self.root = os.path.expanduser(self.root)
    fpath = os.path.join(self.root, self.filename)
    _urlretrieve(self.resources[self.dataset_type], fpath)

    if not os.path.exists(os.path.join(self.root, self.dataset_type)):
        print(f&#39;Extracting &#34;{self.filepath}&#34;&#39;)
        os.system(f&#34;tar -xvf {self.filepath}&#34;)
        os.system(f&#34;mv {self.dataset_type} {self.root}&#34;)
    else:
        print(f&#39;Folder &#34;{self.dataset_type}&#34; already exists.&#39;)

    image_chips = f&#34;{self.dataset_type}/image-chips&#34;
    label_chips = f&#34;{self.dataset_type}/label-chips&#34;

    if not os.path.exists(image_chips):
        os.mkdir(os.path.join(self.root, image_chips))
    if not os.path.exists(label_chips):
        os.mkdir(os.path.join(self.root, label_chips))

    run(os.path.join(self.root, self.dataset_type))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.DroneDeploy.load_dataset"><code class="name flex">
<span>def <span class="ident">load_dataset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_dataset(self):
    if self.data_mode == 0:
        list_chip = &#34;train.txt&#34;
    elif self.data_mode == 1:
        list_chip = &#34;valid.txt&#34;
    elif self.data_mode == 2:
        list_chip = &#34;test.txt&#34;

    files = [
        f&#34;{os.path.join(self.root, self.dataset_type)}/image-chips/{fname}&#34;
        for fname in load_lines(os.path.join(self.root, self.dataset_type, list_chip))
    ]
    self.image_files = files</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.DroneDeploy.on_epoch_end"><code class="name flex">
<span>def <span class="ident">on_epoch_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def on_epoch_end(self):
    random.shuffle(self.image_files)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.EuroSat"><code class="flex name class">
<span>class <span class="ident">EuroSat</span></span>
<span>(</span><span>root: str, transform=Compose(
Resize(size=(64, 64), interpolation=bilinear, max_size=None, antialias=None)
ToTensor()
), target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>EuroSat Land Cover Categories.</p>
<p><a href="http://madm.dfki.de/files/sentinel">http://madm.dfki.de/files/sentinel</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EuroSat(VisionDataset):
    &#34;&#34;&#34;EuroSat Land Cover Categories.

    &lt;http://madm.dfki.de/files/sentinel&gt;

    Args:
        root (string): Root directory of dataset.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;http://madm.dfki.de/files/sentinel&#34;
    resources = &#34;EuroSAT.zip&#34;
    classes = {
        &#34;AnnualCrop&#34;: 0,
        &#34;Forest&#34;: 1,
        &#34;HerbaceousVegetation&#34;: 2,
        &#34;Highway&#34;: 3,
        &#34;Industrial&#34;: 4,
        &#34;Pasture&#34;: 5,
        &#34;PermanentCrop&#34;: 6,
        &#34;Residential&#34;: 7,
        &#34;River&#34;: 8,
        &#34;SeaLake&#34;: 9,
    }

    def __init__(
        self,
        root: str,
        transform=Compose([Resize((64, 64)), ToTensor()]),
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(EuroSat, self).__init__(root, transform=transform, target_transform=target_transform)

        self.root = root
        self.data_mode = &#34;2750&#34;

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        self.img_labels = self.get_path_and_label()

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, target) where target is index of the target class.
        &#34;&#34;&#34;
        img_path = self.img_labels.iloc[idx, 0]
        img = np.array(_load_img(img_path))
        target = self.img_labels.iloc[idx, 1]

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            target = Image.fromarray(target)
            target = self.target_transform(target)
        return img, target

    def __len__(self) -&gt; int:
        return len(self.img_labels)

    def _check_exists(self) -&gt; None:
        self.data_path = os.path.join(self.root, self.data_mode)
        self.dir_classes = list(self.classes.keys())

        return all([os.path.exists(os.path.join(self.data_path, i)) for i in self.dir_classes])

    def download(self) -&gt; None:
        &#34;&#34;&#34;Download file&#34;&#34;&#34;
        file_url = posixpath.join(self.mirrors, self.resources)
        _urlretrieve(file_url, os.path.join(self.root, self.resources))

    def extract_file(self) -&gt; None:
        &#34;&#34;&#34;Extract the .zip file&#34;&#34;&#34;
        shutil.unpack_archive(os.path.join(self.root, self.resources), self.root)
        os.remove(os.path.join(self.root, self.resources))

    def get_path_and_label(self):
        &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label.&#34;&#34;&#34;
        image_path = []
        label = []
        for cat, enc in self.classes.items():
            cat_path = os.path.join(self.root, self.data_mode, cat)
            cat_image = [os.path.join(cat_path, path) for path in os.listdir(cat_path)]
            cat_label = [enc] * len(cat_image)
            image_path += cat_image
            label += cat_label
        df = pd.DataFrame({&#34;image&#34;: image_path, &#34;label&#34;: label})

        return df</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.EuroSat.classes"><code class="name">var <span class="ident">classes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.EuroSat.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.EuroSat.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.EuroSat.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.EuroSat.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;Download file&#34;&#34;&#34;
    file_url = posixpath.join(self.mirrors, self.resources)
    _urlretrieve(file_url, os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.EuroSat.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the .zip file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self) -&gt; None:
    &#34;&#34;&#34;Extract the .zip file&#34;&#34;&#34;
    shutil.unpack_archive(os.path.join(self.root, self.resources), self.root)
    os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.EuroSat.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dataframe type consist of image path and corresponding label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label.&#34;&#34;&#34;
    image_path = []
    label = []
    for cat, enc in self.classes.items():
        cat_path = os.path.join(self.root, self.data_mode, cat)
        cat_image = [os.path.join(cat_path, path) for path in os.listdir(cat_path)]
        cat_label = [enc] * len(cat_image)
        image_path += cat_image
        label += cat_label
    df = pd.DataFrame({&#34;image&#34;: image_path, &#34;label&#34;: label})

    return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.L7Irish"><code class="flex name class">
<span>class <span class="ident">L7Irish</span></span>
<span>(</span><span>root: str, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Landsat 7 Irish Cloud.</p>
<p><a href="https://landsat.usgs.gov/landsat-7-cloud-cover-assessment-validation-data">https://landsat.usgs.gov/landsat-7-cloud-cover-assessment-validation-data</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L7Irish(VisionDataset):
    &#34;&#34;&#34;Landsat 7 Irish Cloud.

    &lt;https://landsat.usgs.gov/landsat-7-cloud-cover-assessment-validation-data&gt;

    Args:
        root (string): Root directory of dataset.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;http://landsat.usgs.gov/cloud-validation/cca_irish_2015/&#34;

    def __init__(
        self,
        root: str,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(L7Irish, self).__init__(root, transform=transform, target_transform=target_transform)

        self.root = root
        self.download_urls = self.get_download_url()
        self.resources = [url.split(&#34;/&#34;)[-1] for url in self.download_urls]
        self.data_modes = [filename.split(&#34;.tar.gz&#34;)[0] for filename in self.resources]

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        self.img_labels = self.get_path_and_label()

    def get_download_url(self):
        &#34;&#34;&#34;Get the urls to download the files.&#34;&#34;&#34;
        page = requests.get(
            &#34;https://landsat.usgs.gov/landsat-7-cloud-cover-assessment-validation-data&#34;
        )
        soup = BeautifulSoup(page.content, &#34;html.parser&#34;)

        urls = [url.get(&#34;href&#34;) for url in soup.find_all(&#34;a&#34;)]
        urls = list(filter(None, urls))

        download_urls = filter(lambda url: url.endswith(&#34;.gz&#34;), urls)
        return download_urls

    def download(self):
        &#34;&#34;&#34;Download file&#34;&#34;&#34;
        for resource in self.resources:
            file_url = posixpath.join(self.mirrors, resource)
            _urlretrieve(file_url, os.path.join(self.root, resource))

    def extract_file(self):
        &#34;&#34;&#34;Extract the .zip file&#34;&#34;&#34;
        for resource in self.resources:
            shutil.unpack_archive(os.path.join(self.root, resource), self.root)
            os.remove(os.path.join(self.root, resource))

    def _check_exists(self):
        is_exists = []
        if not os.path.isdir(self.root):
            os.mkdir(self.root)

        for data_mode in self.data_modes:
            data_path = os.path.join(self.root, data_mode)
            is_exists.append(os.path.exists(data_path))

        return all(is_exists)

    def get_path_and_label(self):
        &#34;&#34;&#34;Get the path of the images and labels (masks) in a dataframe&#34;&#34;&#34;
        image_path, label = [], []

        for data_mode in self.data_modes:
            for image in glob.glob(os.path.join(self.root, data_mode, &#34;L7*.TIF&#34;)):
                image_path.append(image)

                label.extend(glob.glob(os.path.join(self.root, data_mode, &#34;*mask*&#34;)))

        df = pd.DataFrame({&#34;image&#34;: image_path, &#34;label&#34;: label})
        return df

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, mask)
        &#34;&#34;&#34;
        img_path = self.img_labels.iloc[idx, 0]
        mask_path = self.img_labels.iloc[idx, 1]

        img = np.array(_load_img(img_path))
        mask = np.array(_load_img(mask_path))

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            mask = Image.fromarray(mask)
            mask = self.target_transform(mask)
        return img, mask

    def __len__(self) -&gt; int:
        return len(self.img_labels)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.L7Irish.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.L7Irish.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.L7Irish.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Download file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self):
    &#34;&#34;&#34;Download file&#34;&#34;&#34;
    for resource in self.resources:
        file_url = posixpath.join(self.mirrors, resource)
        _urlretrieve(file_url, os.path.join(self.root, resource))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.L7Irish.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the .zip file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self):
    &#34;&#34;&#34;Extract the .zip file&#34;&#34;&#34;
    for resource in self.resources:
        shutil.unpack_archive(os.path.join(self.root, resource), self.root)
        os.remove(os.path.join(self.root, resource))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.L7Irish.get_download_url"><code class="name flex">
<span>def <span class="ident">get_download_url</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the urls to download the files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_download_url(self):
    &#34;&#34;&#34;Get the urls to download the files.&#34;&#34;&#34;
    page = requests.get(
        &#34;https://landsat.usgs.gov/landsat-7-cloud-cover-assessment-validation-data&#34;
    )
    soup = BeautifulSoup(page.content, &#34;html.parser&#34;)

    urls = [url.get(&#34;href&#34;) for url in soup.find_all(&#34;a&#34;)]
    urls = list(filter(None, urls))

    download_urls = filter(lambda url: url.endswith(&#34;.gz&#34;), urls)
    return download_urls</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.L7Irish.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the path of the images and labels (masks) in a dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Get the path of the images and labels (masks) in a dataframe&#34;&#34;&#34;
    image_path, label = [], []

    for data_mode in self.data_modes:
        for image in glob.glob(os.path.join(self.root, data_mode, &#34;L7*.TIF&#34;)):
            image_path.append(image)

            label.extend(glob.glob(os.path.join(self.root, data_mode, &#34;*mask*&#34;)))

    df = pd.DataFrame({&#34;image&#34;: image_path, &#34;label&#34;: label})
    return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.L8Biome"><code class="flex name class">
<span>class <span class="ident">L8Biome</span></span>
<span>(</span><span>root: str, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>L8 Biome Cloud Cover.</p>
<p>Download page <a href="https://landsat.usgs.gov/landsat-8-cloud-cover-assessment-validation-data">https://landsat.usgs.gov/landsat-8-cloud-cover-assessment-validation-data</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L8Biome(VisionDataset):
    &#34;&#34;&#34;L8 Biome Cloud Cover.

    Download page https://landsat.usgs.gov/landsat-8-cloud-cover-assessment-validation-data

    Args:
        root (string): Root directory of dataset.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;https://landsat.usgs.gov/landsat-8-cloud-cover-assessment-validation-data&#34;

    def __init__(
        self,
        root: str,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(L8Biome, self).__init__(root, transform=transform, target_transform=target_transform)

        self.root = root
        self.download_urls = self.get_download_url()
        self.data_modes = [url.split(&#34;/&#34;)[-1] for url in self.download_urls]

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        self.img_labels = self.get_path_and_label()

    def get_download_url(self):
        &#34;&#34;&#34;Get the urls to download the files.&#34;&#34;&#34;
        page = requests.get(self.mirrors)
        soup = BeautifulSoup(page.content, &#34;html.parser&#34;)

        urls = [url.get(&#34;href&#34;) for url in soup.find_all(&#34;a&#34;)]

        download_urls = list(filter(lambda url: url.endswith(&#34;.tar.gz&#34;) if url else None, urls))
        return download_urls

    def download(self):
        &#34;&#34;&#34;Download file&#34;&#34;&#34;
        for resource in self.download_urls:
            filename = resource.split(&#34;/&#34;)[-1]
            _urlretrieve(resource, os.path.join(self.root, filename))

    def extract_file(self):
        &#34;&#34;&#34;Extract the .zip file&#34;&#34;&#34;
        for resource in self.data_modes:
            shutil.unpack_archive(os.path.join(self.root, resource), self.root)
            os.remove(os.path.join(self.root, resource))

    def _check_exists(self):
        is_exists = []
        if not os.path.isdir(self.root):
            os.mkdir(self.root)

        for data_mode in self.data_modes:
            data_mode = data_mode.replace(&#34;.tar.gz&#34;, &#34;&#34;)
            data_path = os.path.join(self.root, &#34;BC&#34;, data_mode)
            is_exists.append(os.path.exists(data_path))

        return all(is_exists)

    def get_path_and_label(self):
        &#34;&#34;&#34;Get the path of the images and labels (masks) in a dataframe&#34;&#34;&#34;
        image_directory, label = [], []

        for data_mode in self.data_modes:
            data_mode = data_mode.replace(&#34;.tar.gz&#34;, &#34;&#34;)
            image_dir = os.path.join(self.root, &#34;BC&#34;, data_mode)

            image_directory.append(image_dir)
            label.extend(glob.glob(os.path.join(self.root, &#34;BC&#34;, data_mode, &#34;*mask.hdr&#34;)))

        df = pd.DataFrame({&#34;image&#34;: image_directory, &#34;label&#34;: label})
        return df

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, mask)
        &#34;&#34;&#34;
        img_directory = self.img_labels.iloc[idx, 0]
        mask_path = self.img_labels.iloc[idx, 1]

        ls_stack_path = []
        for idx in range(1, 12):
            observation = img_directory.split(&#34;/&#34;)[-1]
            name_file = f&#34;{img_directory}/{observation}_B{idx}.TIF&#34;
            ls_stack_path.append(name_file)

        img = _load_stack_img(ls_stack_path)
        mask = _load_img_hdr(mask_path)

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            mask = Image.fromarray(mask)
            mask = self.target_transform(mask)

        return img, mask

    def __len__(self) -&gt; int:
        return len(self.img_labels)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.L8Biome.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.L8Biome.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.L8Biome.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Download file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self):
    &#34;&#34;&#34;Download file&#34;&#34;&#34;
    for resource in self.download_urls:
        filename = resource.split(&#34;/&#34;)[-1]
        _urlretrieve(resource, os.path.join(self.root, filename))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.L8Biome.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the .zip file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self):
    &#34;&#34;&#34;Extract the .zip file&#34;&#34;&#34;
    for resource in self.data_modes:
        shutil.unpack_archive(os.path.join(self.root, resource), self.root)
        os.remove(os.path.join(self.root, resource))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.L8Biome.get_download_url"><code class="name flex">
<span>def <span class="ident">get_download_url</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the urls to download the files.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_download_url(self):
    &#34;&#34;&#34;Get the urls to download the files.&#34;&#34;&#34;
    page = requests.get(self.mirrors)
    soup = BeautifulSoup(page.content, &#34;html.parser&#34;)

    urls = [url.get(&#34;href&#34;) for url in soup.find_all(&#34;a&#34;)]

    download_urls = list(filter(lambda url: url.endswith(&#34;.tar.gz&#34;) if url else None, urls))
    return download_urls</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.L8Biome.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the path of the images and labels (masks) in a dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Get the path of the images and labels (masks) in a dataframe&#34;&#34;&#34;
    image_directory, label = [], []

    for data_mode in self.data_modes:
        data_mode = data_mode.replace(&#34;.tar.gz&#34;, &#34;&#34;)
        image_dir = os.path.join(self.root, &#34;BC&#34;, data_mode)

        image_directory.append(image_dir)
        label.extend(glob.glob(os.path.join(self.root, &#34;BC&#34;, data_mode, &#34;*mask.hdr&#34;)))

    df = pd.DataFrame({&#34;image&#34;: image_directory, &#34;label&#34;: label})
    return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.L8SPARCS"><code class="flex name class">
<span>class <span class="ident">L8SPARCS</span></span>
<span>(</span><span>root: str, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Landsat 8 SPARCS Cloud.</p>
<p><a href="https://www.usgs.gov/core-science-systems/nli/landsat/spatial-procedures-automated-removal-cloud-and-shadow-sparcs">https://www.usgs.gov/core-science-systems/nli/landsat/spatial-procedures-automated-removal-cloud-and-shadow-sparcs</a></p>
<p>Download: <a href="https://landsat.usgs.gov/cloud-validation/sparcs/l8cloudmasks.zip">https://landsat.usgs.gov/cloud-validation/sparcs/l8cloudmasks.zip</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class L8SPARCS(VisionDataset):
    &#34;&#34;&#34;Landsat 8 SPARCS Cloud.
    
    &lt;https://www.usgs.gov/core-science-systems/nli/landsat/spatial-procedures-automated-removal-cloud-and-shadow-sparcs&gt;
    
    Download: &lt;https://landsat.usgs.gov/cloud-validation/sparcs/l8cloudmasks.zip&gt;

    Args:
        root (string): Root directory of dataset.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;https://landsat.usgs.gov/cloud-validation/sparcs/&#34;
    resources = &#34;l8cloudmasks.zip&#34;

    def __init__(
        self,
        root: str,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(L8SPARCS, self).__init__(root, transform=transform, target_transform=target_transform)

        self.root = root
        self.data_mode = &#34;sending&#34;

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        self.img_labels = self.get_path_and_label()

    def _check_exists(self) -&gt; None:
        self.data_path = os.path.join(self.root, self.data_mode)
        return os.path.exists(self.data_path)

    def download(self) -&gt; None:
        &#34;&#34;&#34;Download file&#34;&#34;&#34;
        file_url = posixpath.join(self.mirrors, self.resources)
        _urlretrieve(file_url, os.path.join(self.root, self.resources))

    def extract_file(self) -&gt; None:
        &#34;&#34;&#34;Extract the .zip file&#34;&#34;&#34;
        shutil.unpack_archive(os.path.join(self.root, self.resources), self.root)
        os.remove(os.path.join(self.root, self.resources))

    def get_path_and_label(self):
        &#34;&#34;&#34;Get the path of the images and labels (masks) in a dataframe&#34;&#34;&#34;
        image_path, label = [], []

        for image in glob.glob(os.path.join(self.root, self.data_mode, &#34;*_photo.png&#34;)):
            image_path.append(image)

        for mask in glob.glob(os.path.join(self.root, self.data_mode, &#34;*_mask.png&#34;)):
            label.append(mask)

        df = pd.DataFrame({&#34;image&#34;: sorted(image_path), &#34;label&#34;: sorted(label)})

        return df

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, mask)
        &#34;&#34;&#34;
        img_path = self.img_labels.iloc[idx, 0]
        mask_path = self.img_labels.iloc[idx, 1]

        img = np.array(_load_img(img_path))
        mask = np.array(_load_img(mask_path))

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            mask = Image.fromarray(mask)
            mask = self.target_transform(mask)
        return img, mask

    def __len__(self) -&gt; int:
        return len(self.img_labels)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.L8SPARCS.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.L8SPARCS.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.L8SPARCS.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.L8SPARCS.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;Download file&#34;&#34;&#34;
    file_url = posixpath.join(self.mirrors, self.resources)
    _urlretrieve(file_url, os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.L8SPARCS.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the .zip file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self) -&gt; None:
    &#34;&#34;&#34;Extract the .zip file&#34;&#34;&#34;
    shutil.unpack_archive(os.path.join(self.root, self.resources), self.root)
    os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.L8SPARCS.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the path of the images and labels (masks) in a dataframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Get the path of the images and labels (masks) in a dataframe&#34;&#34;&#34;
    image_path, label = [], []

    for image in glob.glob(os.path.join(self.root, self.data_mode, &#34;*_photo.png&#34;)):
        image_path.append(image)

    for mask in glob.glob(os.path.join(self.root, self.data_mode, &#34;*_mask.png&#34;)):
        label.append(mask)

    df = pd.DataFrame({&#34;image&#34;: sorted(image_path), &#34;label&#34;: sorted(label)})

    return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.LandCover"><code class="flex name class">
<span>class <span class="ident">LandCover</span></span>
<span>(</span><span>root: str, transform=Compose(
Resize(size=(256, 256), interpolation=bilinear, max_size=None, antialias=None)
ToTensor()
), target_transform=Compose(
Resize(size=(256, 256), interpolation=bilinear, max_size=None, antialias=None)
ToTensor()
), download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>The LandCover.ai (Land Cover from Aerial Imagery) dataset.</p>
<p><a href="https://landcover.ai/download/landcover.ai.v1.zip">https://landcover.ai/download/landcover.ai.v1.zip</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LandCover(VisionDataset):
    &#34;&#34;&#34;The LandCover.ai (Land Cover from Aerial Imagery) dataset.

    &lt;https://landcover.ai/download/landcover.ai.v1.zip&gt;

    Args:
        root (string): Root directory of dataset.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;https://landcover.ai/download&#34;
    resources = &#34;landcover.ai.v1.zip&#34;

    def __init__(
        self,
        root: str,
        transform=Compose([Resize((256, 256)), ToTensor()]),
        target_transform=Compose([Resize((256, 256)), ToTensor()]),
        download: bool = False,
    ) -&gt; None:

        super(LandCover, self).__init__(
            root, transform=transform, target_transform=target_transform
        )

        self.root = root

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()
            self.to_chip_img_mask(&#34;landcover&#34;)

        self.img_labels = self.get_image_path_and_mask_path()

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, mask)
        &#34;&#34;&#34;
        img_path = self.img_labels.iloc[idx, 0]
        mask_path = self.img_labels.iloc[idx, 1]
        img = np.array(_load_img(img_path))
        mask = np.array(_load_img(mask_path))

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            mask = Image.fromarray(mask)
            mask = self.target_transform(mask)
        return img, mask

    def __len__(self) -&gt; int:
        return len(self.img_labels)

    def get_image_path_and_mask_path(self):
        &#34;&#34;&#34;Return dataframe type consist of image path and mask path.&#34;&#34;&#34;

        img_path = os.path.join(self.root, &#34;landcover&#34;, &#34;images&#34;)
        msk_path = os.path.join(self.root, &#34;landcover&#34;, &#34;masks&#34;)

        images_path = [os.path.join(img_path, path) for path in os.listdir(img_path)]
        images_path.sort()
        masks_path = [os.path.join(img_path, path) for path in os.listdir(msk_path)]
        masks_path.sort()

        df = pd.DataFrame({&#34;image&#34;: images_path, &#34;mask&#34;: masks_path})
        return df

    def to_chip_img_mask(self, base):
        IMGS_DIR = &#34;./{}/images&#34;.format(base)
        MASKS_DIR = &#34;./{}/masks&#34;.format(base)
        OUTPUT_DIR = &#34;./{}/output&#34;.format(base)
        OUTPUT_IMGS_DIR = &#34;./{}/output/images&#34;.format(base)
        OUTPUT_MASKS_DIR = &#34;./{}/output/masks&#34;.format(base)

        TARGET_SIZE = 512

        img_paths = glob.glob(os.path.join(IMGS_DIR, &#34;*.tif&#34;))
        mask_paths = glob.glob(os.path.join(MASKS_DIR, &#34;*.tif&#34;))

        img_paths.sort()
        mask_paths.sort()

        # os.makedirs(OUTPUT_DIR)
        os.makedirs(OUTPUT_IMGS_DIR)
        os.makedirs(OUTPUT_MASKS_DIR)
        for i, (img_path, mask_path) in enumerate(zip(img_paths, mask_paths)):
            img_filename = os.path.splitext(os.path.basename(img_path))[0]
            mask_filename = os.path.splitext(os.path.basename(mask_path))[0]
            img = cv2.imread(img_path)
            mask = cv2.imread(mask_path)

            assert img_filename == mask_filename and img.shape[:2] == mask.shape[:2]

            k = 0
            for y in range(0, img.shape[0], TARGET_SIZE):
                for x in range(0, img.shape[1], TARGET_SIZE):
                    img_tile = img[y : y + TARGET_SIZE, x : x + TARGET_SIZE]
                    mask_tile = mask[y : y + TARGET_SIZE, x : x + TARGET_SIZE]

                    if img_tile.shape[0] == TARGET_SIZE and img_tile.shape[1] == TARGET_SIZE:
                        out_img_path = os.path.join(
                            OUTPUT_DIR, &#34;images&#34;, &#34;{}_{}.jpg&#34;.format(img_filename, k)
                        )
                        cv2.imwrite(out_img_path, img_tile)

                        out_mask_path = os.path.join(
                            OUTPUT_DIR, &#34;masks&#34;, &#34;{}_{}.png&#34;.format(mask_filename, k)
                        )
                        cv2.imwrite(out_mask_path, mask_tile)

                    k += 1

            print(&#34;Processed {} {}/{}&#34;.format(img_filename, i + 1, len(img_paths)))

    def download(self) -&gt; None:
        &#34;&#34;&#34;download and extract file.&#34;&#34;&#34;
        file_url = posixpath.join(self.mirrors, self.resources)
        _urlretrieve(file_url, os.path.join(self.root, self.resources))

    def _check_exists(self):
        &#34;&#34;&#34;Check file has been download or not&#34;&#34;&#34;
        self.data_path = os.path.join(
            self.root,
            &#34;landcover&#34;,
        )

        return os.path.exists(os.path.join(self.data_path, &#34;images&#34;)) and os.path.exists(
            os.path.join(self.data_path, &#34;masks&#34;)
        )

    def extract_file(self):
        &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;
        os.makedirs(os.path.join(self.root, &#34;landcover&#34;))
        shutil.unpack_archive(
            os.path.join(self.root, self.resources), os.path.join(self.root, &#34;landcover&#34;)
        )
        os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.LandCover.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.LandCover.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.LandCover.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.LandCover.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>download and extract file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;download and extract file.&#34;&#34;&#34;
    file_url = posixpath.join(self.mirrors, self.resources)
    _urlretrieve(file_url, os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.LandCover.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract file from compressed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self):
    &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;
    os.makedirs(os.path.join(self.root, &#34;landcover&#34;))
    shutil.unpack_archive(
        os.path.join(self.root, self.resources), os.path.join(self.root, &#34;landcover&#34;)
    )
    os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.LandCover.get_image_path_and_mask_path"><code class="name flex">
<span>def <span class="ident">get_image_path_and_mask_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dataframe type consist of image path and mask path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image_path_and_mask_path(self):
    &#34;&#34;&#34;Return dataframe type consist of image path and mask path.&#34;&#34;&#34;

    img_path = os.path.join(self.root, &#34;landcover&#34;, &#34;images&#34;)
    msk_path = os.path.join(self.root, &#34;landcover&#34;, &#34;masks&#34;)

    images_path = [os.path.join(img_path, path) for path in os.listdir(img_path)]
    images_path.sort()
    masks_path = [os.path.join(img_path, path) for path in os.listdir(msk_path)]
    masks_path.sort()

    df = pd.DataFrame({&#34;image&#34;: images_path, &#34;mask&#34;: masks_path})
    return df</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.LandCover.to_chip_img_mask"><code class="name flex">
<span>def <span class="ident">to_chip_img_mask</span></span>(<span>self, base)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_chip_img_mask(self, base):
    IMGS_DIR = &#34;./{}/images&#34;.format(base)
    MASKS_DIR = &#34;./{}/masks&#34;.format(base)
    OUTPUT_DIR = &#34;./{}/output&#34;.format(base)
    OUTPUT_IMGS_DIR = &#34;./{}/output/images&#34;.format(base)
    OUTPUT_MASKS_DIR = &#34;./{}/output/masks&#34;.format(base)

    TARGET_SIZE = 512

    img_paths = glob.glob(os.path.join(IMGS_DIR, &#34;*.tif&#34;))
    mask_paths = glob.glob(os.path.join(MASKS_DIR, &#34;*.tif&#34;))

    img_paths.sort()
    mask_paths.sort()

    # os.makedirs(OUTPUT_DIR)
    os.makedirs(OUTPUT_IMGS_DIR)
    os.makedirs(OUTPUT_MASKS_DIR)
    for i, (img_path, mask_path) in enumerate(zip(img_paths, mask_paths)):
        img_filename = os.path.splitext(os.path.basename(img_path))[0]
        mask_filename = os.path.splitext(os.path.basename(mask_path))[0]
        img = cv2.imread(img_path)
        mask = cv2.imread(mask_path)

        assert img_filename == mask_filename and img.shape[:2] == mask.shape[:2]

        k = 0
        for y in range(0, img.shape[0], TARGET_SIZE):
            for x in range(0, img.shape[1], TARGET_SIZE):
                img_tile = img[y : y + TARGET_SIZE, x : x + TARGET_SIZE]
                mask_tile = mask[y : y + TARGET_SIZE, x : x + TARGET_SIZE]

                if img_tile.shape[0] == TARGET_SIZE and img_tile.shape[1] == TARGET_SIZE:
                    out_img_path = os.path.join(
                        OUTPUT_DIR, &#34;images&#34;, &#34;{}_{}.jpg&#34;.format(img_filename, k)
                    )
                    cv2.imwrite(out_img_path, img_tile)

                    out_mask_path = os.path.join(
                        OUTPUT_DIR, &#34;masks&#34;, &#34;{}_{}.png&#34;.format(mask_filename, k)
                    )
                    cv2.imwrite(out_mask_path, mask_tile)

                k += 1

        print(&#34;Processed {} {}/{}&#34;.format(img_filename, i + 1, len(img_paths)))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.RESISC45"><code class="flex name class">
<span>class <span class="ident">RESISC45</span></span>
<span>(</span><span>root: str, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>RESISC45 Dataset.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RESISC45(VisionDataset):
    &#34;&#34;&#34;RESISC45 Dataset.

    Args:
        root (string): Root directory of dataset.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;https://storage.googleapis.com/ossjr&#34;
    resources = &#34;NWPU-RESISC45.zip&#34;

    def __init__(
        self,
        root: str,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(RESISC45, self).__init__(root, transform=transform, target_transform=target_transform)

        self.root = root
        self.class_enc = CLASS_ENC
        self.class_dec = CLASS_DEC

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        self.img_labels = self.get_path_and_label()

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, target) where target is index of the target class.
        &#34;&#34;&#34;
        img_path = self.img_labels.iloc[idx, 0]
        img = np.array(_load_img(img_path))
        target = self.img_labels.iloc[idx, 1]

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            target = Image.fromarray(target)
            target = self.target_transform(target)
        return img, target

    def __len__(self) -&gt; int:
        return len(self.img_labels)

    def get_path_and_label(self):
        &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label.&#34;&#34;&#34;
        DATA_SIZE = 700
        category = os.listdir(os.path.join(self.root, &#34;NWPU-RESISC45&#34;))
        image_path = []
        label = []
        for cat in category:
            cat_enc = self.class_enc[cat]
            label += [cat_enc] * DATA_SIZE
            for num in range(1, DATA_SIZE + 1):
                filename = cat + &#34;_&#34; + str(num).zfill(3) + &#34;.jpg&#34;
                image_path += [os.path.join(self.root, &#34;NWPU-RESISC45&#34;, cat, filename)]
        df = pd.DataFrame({&#34;image&#34;: image_path, &#34;label&#34;: label})

        return df

    def _check_exists(self):
        is_exists = os.path.exists(os.path.join(self.root, &#34;NWPU-RESISC45&#34;))
        return is_exists

    def download(self) -&gt; None:
        &#34;&#34;&#34;Download and extract file.&#34;&#34;&#34;
        file_url = posixpath.join(self.mirrors, self.resources)
        _urlretrieve(file_url, os.path.join(self.root, self.resources))

    def extract_file(self) -&gt; None:
        &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;
        shutil.unpack_archive(os.path.join(self.root, self.resources), f&#34;{self.root}&#34;)
        os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.RESISC45.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.RESISC45.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.RESISC45.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.RESISC45.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Download and extract file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;Download and extract file.&#34;&#34;&#34;
    file_url = posixpath.join(self.mirrors, self.resources)
    _urlretrieve(file_url, os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.RESISC45.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Extract file from compressed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self) -&gt; None:
    &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;
    shutil.unpack_archive(os.path.join(self.root, self.resources), f&#34;{self.root}&#34;)
    os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.RESISC45.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dataframe type consist of image path and corresponding label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label.&#34;&#34;&#34;
    DATA_SIZE = 700
    category = os.listdir(os.path.join(self.root, &#34;NWPU-RESISC45&#34;))
    image_path = []
    label = []
    for cat in category:
        cat_enc = self.class_enc[cat]
        label += [cat_enc] * DATA_SIZE
        for num in range(1, DATA_SIZE + 1):
            filename = cat + &#34;_&#34; + str(num).zfill(3) + &#34;.jpg&#34;
            image_path += [os.path.join(self.root, &#34;NWPU-RESISC45&#34;, cat, filename)]
    df = pd.DataFrame({&#34;image&#34;: image_path, &#34;label&#34;: label})

    return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.Sentinel2Cloud"><code class="flex name class">
<span>class <span class="ident">Sentinel2Cloud</span></span>
<span>(</span><span>root: str, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Sentinel-2 Cloud Mask Catalogue dataset.</p>
<p>classification_tags: <a href="https://zenodo.org/record/4172871/files/classification_tags.csv?download=1">https://zenodo.org/record/4172871/files/classification_tags.csv?download=1</a>
subscenes: <a href="https://zenodo.org/record/4172871/files/subscenes.zip?download=1">https://zenodo.org/record/4172871/files/subscenes.zip?download=1</a>
masks: <a href="https://zenodo.org/record/4172871/files/masks.zip?download=1">https://zenodo.org/record/4172871/files/masks.zip?download=1</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sentinel2Cloud(VisionDataset):
    &#34;&#34;&#34;Sentinel-2 Cloud Mask Catalogue dataset.
    
    classification_tags: &lt;https://zenodo.org/record/4172871/files/classification_tags.csv?download=1&gt;
    subscenes: &lt;https://zenodo.org/record/4172871/files/subscenes.zip?download=1&gt;
    masks: &lt;https://zenodo.org/record/4172871/files/masks.zip?download=1&gt;

    Args:
        root (string): Root directory of dataset.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;https://zenodo.org/record/4172871/files/&#34;
    resources = &#34;subscenes.zip&#34;
    mask_resources = &#34;masks.zip&#34;

    def __init__(
        self,
        root: str,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(Sentinel2Cloud, self).__init__(
            root, transform=transform, target_transform=target_transform
        )

        self.root = root

        if not os.path.exists(self.root):
            os.makedirs(self.root)

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        self.img_labels = self.get_image_path_and_mask_path()

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, mask)
        &#34;&#34;&#34;
        img_path = self.img_labels.iloc[idx, 0]
        mask_path = self.img_labels.iloc[idx, 1]

        img = _load_npy(img_path)
        mask = _load_npy(mask_path)

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            mask = Image.fromarray(mask)
            mask = self.target_transform(mask)
        return img, mask

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the len of the image labels&#34;&#34;&#34;
        return len(self.img_labels)

    def get_image_path_and_mask_path(self):
        &#34;&#34;&#34;Return dataframe type consist of image path and mask path.&#34;&#34;&#34;

        img_path = os.path.join(self.root, &#34;sentinel2cloud&#34;, &#34;subscenes&#34;)
        msk_path = os.path.join(self.root, &#34;sentinel2cloud&#34;, &#34;masks&#34;)

        images_path = glob.glob(os.path.join(img_path, &#34;*.npy&#34;))
        images_path.sort()
        masks_path = glob.glob(os.path.join(msk_path, &#34;*.npy&#34;))
        masks_path.sort()

        df = pd.DataFrame({&#34;image&#34;: images_path, &#34;mask&#34;: masks_path})
        return df

    def download(self) -&gt; None:
        &#34;&#34;&#34;download and extract file.&#34;&#34;&#34;
        file_url = posixpath.join(self.mirrors, self.resources)
        _urlretrieve(file_url, os.path.join(self.root, self.resources))

        mask_file_url = posixpath.join(self.mirrors, self.mask_resources)
        _urlretrieve(mask_file_url, os.path.join(self.root, self.mask_resources))

    def _check_exists(self):
        &#34;&#34;&#34;Check file has been download or not&#34;&#34;&#34;
        self.data_path = os.path.join(self.root, &#34;sentinel2cloud&#34;)

        return os.path.exists(os.path.join(self.data_path, &#34;subscenes&#34;)) and os.path.exists(
            os.path.join(self.data_path, &#34;masks&#34;)
        )

    def extract_file(self):
        &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;

        os.makedirs(os.path.join(self.root, &#34;sentinel2cloud&#34;))

        shutil.unpack_archive(
            os.path.join(self.root, self.resources), os.path.join(self.root, &#34;sentinel2cloud&#34;)
        )
        os.remove(os.path.join(self.root, self.resources))

        shutil.unpack_archive(
            os.path.join(self.root, self.mask_resources), os.path.join(self.root, &#34;sentinel2cloud&#34;)
        )
        os.remove(os.path.join(self.root, self.mask_resources))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.Sentinel2Cloud.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.Sentinel2Cloud.mask_resources"><code class="name">var <span class="ident">mask_resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.Sentinel2Cloud.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.Sentinel2Cloud.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.Sentinel2Cloud.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>download and extract file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;download and extract file.&#34;&#34;&#34;
    file_url = posixpath.join(self.mirrors, self.resources)
    _urlretrieve(file_url, os.path.join(self.root, self.resources))

    mask_file_url = posixpath.join(self.mirrors, self.mask_resources)
    _urlretrieve(mask_file_url, os.path.join(self.root, self.mask_resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.Sentinel2Cloud.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract file from compressed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self):
    &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;

    os.makedirs(os.path.join(self.root, &#34;sentinel2cloud&#34;))

    shutil.unpack_archive(
        os.path.join(self.root, self.resources), os.path.join(self.root, &#34;sentinel2cloud&#34;)
    )
    os.remove(os.path.join(self.root, self.resources))

    shutil.unpack_archive(
        os.path.join(self.root, self.mask_resources), os.path.join(self.root, &#34;sentinel2cloud&#34;)
    )
    os.remove(os.path.join(self.root, self.mask_resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.Sentinel2Cloud.get_image_path_and_mask_path"><code class="name flex">
<span>def <span class="ident">get_image_path_and_mask_path</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dataframe type consist of image path and mask path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_image_path_and_mask_path(self):
    &#34;&#34;&#34;Return dataframe type consist of image path and mask path.&#34;&#34;&#34;

    img_path = os.path.join(self.root, &#34;sentinel2cloud&#34;, &#34;subscenes&#34;)
    msk_path = os.path.join(self.root, &#34;sentinel2cloud&#34;, &#34;masks&#34;)

    images_path = glob.glob(os.path.join(img_path, &#34;*.npy&#34;))
    images_path.sort()
    masks_path = glob.glob(os.path.join(msk_path, &#34;*.npy&#34;))
    masks_path.sort()

    df = pd.DataFrame({&#34;image&#34;: images_path, &#34;mask&#34;: masks_path})
    return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.So2Sat"><code class="flex name class">
<span>class <span class="ident">So2Sat</span></span>
<span>(</span><span>root: str, train: bool = True, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>So2Sat Dataset to Predict Local Climate Zone (LCZ): </p>
<p><a href="https://mediatum.ub.tum.de/1454690">https://mediatum.ub.tum.de/1454690</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>train</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, creates dataset from training set, otherwise
creates from validation set.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class So2Sat(VisionDataset):
    &#34;&#34;&#34;So2Sat Dataset to Predict Local Climate Zone (LCZ): 
    
    &lt;https://mediatum.ub.tum.de/1454690&gt;

    Args:
        root (string): Root directory of dataset.
        train (bool, optional): If True, creates dataset from training set, otherwise
            creates from validation set.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;https://dataserv.ub.tum.de/s/m1454690/download?path=/&amp;files=&#34;
    resources = [&#34;training.h5&#34;, &#34;validation.h5&#34;]

    def __init__(
        self,
        root: str,
        train: bool = True,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = True,
    ) -&gt; None:

        super(So2Sat, self).__init__(root, transform=transform, target_transform=target_transform)

        self.root = root
        self.data_mode = &#34;training&#34; if train else &#34;validation&#34;

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()

        self.img_labels = self.get_path_and_label()

    def __len__(self) -&gt; int:
        return len(self.img_labels)

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (sen1, sen2, label)
        &#34;&#34;&#34;
        sen1 = self.img_labels[&#34;sen1&#34;][idx]
        sen2 = self.img_labels[&#34;sen2&#34;][idx]
        label = self.img_labels[&#34;label&#34;][idx]

        if self.transform is not None:
            sen1 = Image.fromarray(sen1)
            sen1 = self.transform(sen1)

            sen2 = Image.fromarray(sen2)
            sen2 = self.transform(sen2)

        if self.target_transform is not None:
            label = Image.fromarray(label)
            label = self.target_transform(label)

        return (sen1, sen2, label)

    def get_path_and_label(self):
        &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label.&#34;&#34;&#34;
        file = h5py.File(os.path.join(self.root, f&#34;{self.data_mode}.h5&#34;), &#34;r&#34;)

        sen1 = np.array(file[&#34;sen1&#34;])
        sen2 = np.array(file[&#34;sen2&#34;])
        label = np.array(file[&#34;label&#34;])

        return {&#34;sen1&#34;: sen1, &#34;sen2&#34;: sen2, &#34;label&#34;: label}

    def _check_exists(self):
        return os.path.exists(os.path.join(self.root, self.resources[0])) and os.path.exists(
            os.path.join(self.root, self.resources[1])
        )

    def download(self):
        &#34;&#34;&#34;Download and extract file.&#34;&#34;&#34;
        if not os.path.exists(self.root):
            os.makedirs(self.root)

        for resource in self.resources:
            file_url = posixpath.join(self.mirrors, resource)
            _urlretrieve(file_url, os.path.join(self.root, resource))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.So2Sat.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.So2Sat.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.So2Sat.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.So2Sat.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Download and extract file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self):
    &#34;&#34;&#34;Download and extract file.&#34;&#34;&#34;
    if not os.path.exists(self.root):
        os.makedirs(self.root)

    for resource in self.resources:
        file_url = posixpath.join(self.mirrors, resource)
        _urlretrieve(file_url, os.path.join(self.root, resource))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.So2Sat.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dataframe type consist of image path and corresponding label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label.&#34;&#34;&#34;
    file = h5py.File(os.path.join(self.root, f&#34;{self.data_mode}.h5&#34;), &#34;r&#34;)

    sen1 = np.array(file[&#34;sen1&#34;])
    sen2 = np.array(file[&#34;sen2&#34;])
    label = np.array(file[&#34;label&#34;])

    return {&#34;sen1&#34;: sen1, &#34;sen2&#34;: sen2, &#34;label&#34;: label}</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.SpaceNet7"><code class="flex name class">
<span>class <span class="ident">SpaceNet7</span></span>
<span>(</span><span>root: str, train: bool = True, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>SpaceNet7 (SN7): Multi-Temporal Urban Development Challenge</p>
<p><a href="https://spacenet.ai/sn7-challenge/">https://spacenet.ai/sn7-challenge/</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>train</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, creates dataset from training set, otherwise
creates from test set.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SpaceNet7(VisionDataset):
    &#34;&#34;&#34;SpaceNet7 (SN7): Multi-Temporal Urban Development Challenge
    
    &lt;https://spacenet.ai/sn7-challenge/&gt;

    Args:
        root (string): Root directory of dataset.
        train (bool, optional): If True, creates dataset from training set, otherwise
            creates from test set.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    resources = {
        &#34;train&#34;: &#34;s3://spacenet-dataset/spacenet/SN7_buildings/tarballs/SN7_buildings_train.tar.gz&#34;,
        &#34;test&#34;: &#34;s3://spacenet-dataset/spacenet/SN7_buildings/tarballs/SN7_buildings_test_public.tar.gz&#34;,
    }

    def __init__(
        self,
        root: str,
        train: bool = True,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(SpaceNet7, self).__init__(
            root, transform=transform, target_transform=target_transform
        )

        self.root = root
        self.data_mode = &#34;train&#34; if train else &#34;test&#34;
        self.filename = self.resources.get(self.data_mode, &#34;NULL&#34;).split(&#34;/&#34;)[-1]
        self.dataset_path = os.path.join(root, self.filename)
        data_mode_folder = {&#34;train&#34;: &#34;train&#34;, &#34;test&#34;: &#34;test_public&#34;}
        self.folder_name = data_mode_folder.get(self.data_mode, &#34;NULL&#34;)

        if not os.path.exists(self.root):
            os.makedirs(self.root)

        if download and self._check_exists(self.dataset_path):
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists(os.path.join(self.root, self.folder_name)):
            self.download()
            self.extract_file()

        if self.data_mode == &#34;train&#34;:
            aois = sorted(
                [
                    f
                    for f in os.listdir(os.path.join(self.root, &#34;train&#34;))
                    if os.path.isdir(os.path.join(self.root, &#34;train&#34;, f))
                ]
            )

            aois_without_mask = []
            for aoi in aois:
                mask_dir = os.path.join(self.root, &#34;train&#34;, aoi, &#34;masks/&#34;)
                if not self._check_exists(mask_dir):
                    aois_without_mask.append(aoi)

            if aois_without_mask:
                print(&#34;Generating masks...&#34;)
                self.generate_mask(aois_without_mask)

        self.img_labels = self.get_path_and_label()

    def _check_exists(self, obj) -&gt; bool:
        if os.path.exists(obj):
            return True
        else:
            return False

    def download(self):
        &#34;&#34;&#34;Download dataset and extract it&#34;&#34;&#34;
        if self.data_mode not in self.resources.keys():
            raise ValueError(&#34;Unrecognized data_mode&#34;)

        downloader(self.resources[self.data_mode], self.root)

    def extract_file(self):
        shutil.unpack_archive(self.dataset_path, self.root)

    def generate_mask(self, aois):
        &#34;&#34;&#34;
        Create Training Masks
        Multi-thread to increase speed
        We&#39;ll only make a 1-channel mask for now, but Solaris supports a multi-channel mask as well, see
            https://github.com/CosmiQ/solaris/blob/master/docs/tutorials/notebooks/api_masks_tutorial.ipynb
        &#34;&#34;&#34;
        make_fbc = False

        input_args = []
        for i, aoi in enumerate(aois):
            print(i, &#34;aoi:&#34;, aoi)
            im_dir = os.path.join(self.root, &#34;train&#34;, aoi, &#34;images_masked/&#34;)
            json_dir = os.path.join(self.root, &#34;train&#34;, aoi, &#34;labels_match/&#34;)
            out_dir_mask = os.path.join(self.root, &#34;train&#34;, aoi, &#34;masks/&#34;)
            out_dir_mask_fbc = os.path.join(self.root, &#34;train&#34;, aoi, &#34;masks_fbc/&#34;)
            os.makedirs(out_dir_mask, exist_ok=True)
            if make_fbc:
                os.makedirs(out_dir_mask_fbc, exist_ok=True)

            json_files = sorted(
                [
                    f
                    for f in os.listdir(os.path.join(json_dir))
                    if f.endswith(&#34;Buildings.geojson&#34;) and os.path.exists(os.path.join(json_dir, f))
                ]
            )
            for j, f in enumerate(json_files):
                # print(i, j, f)
                name_root = f.split(&#34;.&#34;)[0]
                json_path = os.path.join(json_dir, f)
                image_path = (
                    os.path.join(im_dir, name_root + &#34;.tif&#34;)
                    .replace(&#34;labels&#34;, &#34;images&#34;)
                    .replace(&#34;_Buildings&#34;, &#34;&#34;)
                )
                output_path_mask = os.path.join(out_dir_mask, name_root + &#34;.tif&#34;)
                if make_fbc:
                    output_path_mask_fbc = os.path.join(out_dir_mask_fbc, name_root + &#34;.tif&#34;)
                else:
                    output_path_mask_fbc = None

                if os.path.exists(output_path_mask):
                    continue
                else:
                    input_args.append(
                        [
                            make_geojsons_and_masks,
                            name_root,
                            image_path,
                            json_path,
                            output_path_mask,
                            output_path_mask_fbc,
                        ]
                    )

        p = multiprocessing.Pool(multiprocessing.cpu_count() - 1)
        out = p.map(map_wrapper, input_args)
        p.close()
        p.join()

    def get_path_and_label(self):
        &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label (for train data),
        or image path only (for test data).&#34;&#34;&#34;
        pops = [&#34;train&#34;, &#34;test_public&#34;]

        for pop in pops:
            d = os.path.join(self.root, pop)
            im_list, mask_list = [], []
            subdirs = sorted([f for f in os.listdir(d) if os.path.isdir(os.path.join(d, f))])
            for subdir in subdirs:
                if pop == &#34;train&#34;:
                    im_files = [
                        os.path.join(d, subdir, &#34;images_masked&#34;, f)
                        for f in sorted(os.listdir(os.path.join(d, subdir, &#34;images_masked&#34;)))
                        if f.endswith(&#34;.tif&#34;)
                        and os.path.exists(
                            os.path.join(d, subdir, &#34;masks&#34;, f.split(&#34;.&#34;)[0] + &#34;_Buildings.tif&#34;)
                        )
                    ]
                    mask_files = [
                        os.path.join(d, subdir, &#34;masks&#34;, f.split(&#34;.&#34;)[0] + &#34;_Buildings.tif&#34;)
                        for f in sorted(os.listdir(os.path.join(d, subdir, &#34;images_masked&#34;)))
                        if f.endswith(&#34;.tif&#34;)
                        and os.path.exists(
                            os.path.join(d, subdir, &#34;masks&#34;, f.split(&#34;.&#34;)[0] + &#34;_Buildings.tif&#34;)
                        )
                    ]
                    im_list.extend(im_files)
                    mask_list.extend(mask_files)

                elif pop == &#34;test_public&#34;:
                    im_files = [
                        os.path.join(d, subdir, &#34;images_masked&#34;, f)
                        for f in sorted(os.listdir(os.path.join(d, subdir, &#34;images_masked&#34;)))
                        if f.endswith(&#34;.tif&#34;)
                    ]
                    im_list.extend(im_files)

            if self.data_mode == &#34;train&#34;:
                df = pd.DataFrame({&#34;image&#34;: im_list, &#34;label&#34;: mask_list})
            elif self.data_mode == &#34;test&#34;:
                df = pd.DataFrame({&#34;image&#34;: im_list})

            return df

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, mask) or (img)
        &#34;&#34;&#34;
        img_path = self.img_labels.iloc[idx, 0]
        img = np.array(_load_img(img_path))

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.data_mode == &#34;train&#34;:
            mask_path = self.img_labels.iloc[idx, 1]
            mask = np.array(_load_img(mask_path))

            if self.target_transform is not None:
                mask = Image.fromarray(mask)
                mask = self.target_transform(mask)
            sample = (img, mask)

        elif self.data_mode == &#34;test&#34;:
            sample = img

        return sample

    def __len__(self) -&gt; int:
        return len(self.img_labels)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.SpaceNet7.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.SpaceNet7.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.SpaceNet7.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Download dataset and extract it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self):
    &#34;&#34;&#34;Download dataset and extract it&#34;&#34;&#34;
    if self.data_mode not in self.resources.keys():
        raise ValueError(&#34;Unrecognized data_mode&#34;)

    downloader(self.resources[self.data_mode], self.root)</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.SpaceNet7.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self):
    shutil.unpack_archive(self.dataset_path, self.root)</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.SpaceNet7.generate_mask"><code class="name flex">
<span>def <span class="ident">generate_mask</span></span>(<span>self, aois)</span>
</code></dt>
<dd>
<div class="desc"><p>Create Training Masks
Multi-thread to increase speed
We'll only make a 1-channel mask for now, but Solaris supports a multi-channel mask as well, see
<a href="https://github.com/CosmiQ/solaris/blob/master/docs/tutorials/notebooks/api_masks_tutorial.ipynb">https://github.com/CosmiQ/solaris/blob/master/docs/tutorials/notebooks/api_masks_tutorial.ipynb</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_mask(self, aois):
    &#34;&#34;&#34;
    Create Training Masks
    Multi-thread to increase speed
    We&#39;ll only make a 1-channel mask for now, but Solaris supports a multi-channel mask as well, see
        https://github.com/CosmiQ/solaris/blob/master/docs/tutorials/notebooks/api_masks_tutorial.ipynb
    &#34;&#34;&#34;
    make_fbc = False

    input_args = []
    for i, aoi in enumerate(aois):
        print(i, &#34;aoi:&#34;, aoi)
        im_dir = os.path.join(self.root, &#34;train&#34;, aoi, &#34;images_masked/&#34;)
        json_dir = os.path.join(self.root, &#34;train&#34;, aoi, &#34;labels_match/&#34;)
        out_dir_mask = os.path.join(self.root, &#34;train&#34;, aoi, &#34;masks/&#34;)
        out_dir_mask_fbc = os.path.join(self.root, &#34;train&#34;, aoi, &#34;masks_fbc/&#34;)
        os.makedirs(out_dir_mask, exist_ok=True)
        if make_fbc:
            os.makedirs(out_dir_mask_fbc, exist_ok=True)

        json_files = sorted(
            [
                f
                for f in os.listdir(os.path.join(json_dir))
                if f.endswith(&#34;Buildings.geojson&#34;) and os.path.exists(os.path.join(json_dir, f))
            ]
        )
        for j, f in enumerate(json_files):
            # print(i, j, f)
            name_root = f.split(&#34;.&#34;)[0]
            json_path = os.path.join(json_dir, f)
            image_path = (
                os.path.join(im_dir, name_root + &#34;.tif&#34;)
                .replace(&#34;labels&#34;, &#34;images&#34;)
                .replace(&#34;_Buildings&#34;, &#34;&#34;)
            )
            output_path_mask = os.path.join(out_dir_mask, name_root + &#34;.tif&#34;)
            if make_fbc:
                output_path_mask_fbc = os.path.join(out_dir_mask_fbc, name_root + &#34;.tif&#34;)
            else:
                output_path_mask_fbc = None

            if os.path.exists(output_path_mask):
                continue
            else:
                input_args.append(
                    [
                        make_geojsons_and_masks,
                        name_root,
                        image_path,
                        json_path,
                        output_path_mask,
                        output_path_mask_fbc,
                    ]
                )

    p = multiprocessing.Pool(multiprocessing.cpu_count() - 1)
    out = p.map(map_wrapper, input_args)
    p.close()
    p.join()</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.SpaceNet7.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dataframe type consist of image path and corresponding label (for train data),
or image path only (for test data).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label (for train data),
    or image path only (for test data).&#34;&#34;&#34;
    pops = [&#34;train&#34;, &#34;test_public&#34;]

    for pop in pops:
        d = os.path.join(self.root, pop)
        im_list, mask_list = [], []
        subdirs = sorted([f for f in os.listdir(d) if os.path.isdir(os.path.join(d, f))])
        for subdir in subdirs:
            if pop == &#34;train&#34;:
                im_files = [
                    os.path.join(d, subdir, &#34;images_masked&#34;, f)
                    for f in sorted(os.listdir(os.path.join(d, subdir, &#34;images_masked&#34;)))
                    if f.endswith(&#34;.tif&#34;)
                    and os.path.exists(
                        os.path.join(d, subdir, &#34;masks&#34;, f.split(&#34;.&#34;)[0] + &#34;_Buildings.tif&#34;)
                    )
                ]
                mask_files = [
                    os.path.join(d, subdir, &#34;masks&#34;, f.split(&#34;.&#34;)[0] + &#34;_Buildings.tif&#34;)
                    for f in sorted(os.listdir(os.path.join(d, subdir, &#34;images_masked&#34;)))
                    if f.endswith(&#34;.tif&#34;)
                    and os.path.exists(
                        os.path.join(d, subdir, &#34;masks&#34;, f.split(&#34;.&#34;)[0] + &#34;_Buildings.tif&#34;)
                    )
                ]
                im_list.extend(im_files)
                mask_list.extend(mask_files)

            elif pop == &#34;test_public&#34;:
                im_files = [
                    os.path.join(d, subdir, &#34;images_masked&#34;, f)
                    for f in sorted(os.listdir(os.path.join(d, subdir, &#34;images_masked&#34;)))
                    if f.endswith(&#34;.tif&#34;)
                ]
                im_list.extend(im_files)

        if self.data_mode == &#34;train&#34;:
            df = pd.DataFrame({&#34;image&#34;: im_list, &#34;label&#34;: mask_list})
        elif self.data_mode == &#34;test&#34;:
            df = pd.DataFrame({&#34;image&#34;: im_list})

        return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.UCMercedLand"><code class="flex name class">
<span>class <span class="ident">UCMercedLand</span></span>
<span>(</span><span>root: str, transform=Compose(
Resize(size=(256, 256), interpolation=bilinear, max_size=None, antialias=None)
ToTensor()
), target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>UC Merced Land Use Dataset.</p>
<p><a href="http://weegee.vision.ucmerced.edu/datasets/UCMerced_LandUse.zip">http://weegee.vision.ucmerced.edu/datasets/UCMerced_LandUse.zip</a></p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UCMercedLand(VisionDataset):
    &#34;&#34;&#34;UC Merced Land Use Dataset.

    &lt;http://weegee.vision.ucmerced.edu/datasets/UCMerced_LandUse.zip&gt;

    Args:
        root (string): Root directory of dataset.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.
    &#34;&#34;&#34;

    mirrors = &#34;http://weegee.vision.ucmerced.edu/datasets/&#34;
    resources = &#34;UCMerced_LandUse.zip&#34;
    classes = {
        &#34;agricultural&#34;: 0,
        &#34;airplane&#34;: 1,
        &#34;baseballdiamond&#34;: 2,
        &#34;beach&#34;: 3,
        &#34;buildings&#34;: 4,
        &#34;chaparral&#34;: 5,
        &#34;denseresidential&#34;: 6,
        &#34;forest&#34;: 7,
        &#34;freeway&#34;: 8,
        &#34;golfcourse&#34;: 9,
        &#34;harbor&#34;: 10,
        &#34;intersection&#34;: 11,
        &#34;mediumresidential&#34;: 12,
        &#34;mobilehomepark&#34;: 13,
        &#34;overpass&#34;: 14,
        &#34;parkinglot&#34;: 15,
        &#34;river&#34;: 16,
        &#34;runway&#34;: 17,
        &#34;sparseresidential&#34;: 18,
        &#34;storagetanks&#34;: 19,
        &#34;tenniscourt&#34;: 20,
    }

    def __init__(
        self,
        root: str,
        transform=Compose([Resize((256, 256)), ToTensor()]),
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(UCMercedLand, self).__init__(
            root, transform=transform, target_transform=target_transform
        )

        self.root = root
        self.data_mode = &#34;Images&#34;

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        self.img_labels = self.get_path_and_label()

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, target) where target is index of the target class.
        &#34;&#34;&#34;
        img_path = self.img_labels.iloc[idx, 0]
        img = np.array(_load_img(img_path))
        target = self.img_labels.iloc[idx, 1]

        if self.transform is not None:
            img = Image.fromarray(img)
            img = self.transform(img)

        if self.target_transform is not None:
            target = Image.fromarray(target)
            target = self.target_transform(target)
        return img, target

    def __len__(self) -&gt; int:
        return len(self.img_labels)

    def get_path_and_label(self):
        &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label.&#34;&#34;&#34;
        image_path = []
        label = []
        for cat, enc in self.classes.items():
            cat_path = os.path.join(self.root, &#34;UCMerced_LandUse&#34;, self.data_mode, cat)
            cat_image = [os.path.join(cat_path, path) for path in os.listdir(cat_path)]
            cat_label = [enc] * len(cat_image)
            image_path += cat_image
            label += cat_label
        df = pd.DataFrame({&#34;image&#34;: image_path, &#34;label&#34;: label})

        return df

    def _check_exists(self):
        self.data_path = os.path.join(self.root, &#34;UCMerced_LandUse&#34;, &#34;Images&#34;)
        self.dir_classes = list(self.classes.keys())
        return all([os.path.exists(os.path.join(self.data_path, i)) for i in self.dir_classes])

    def download(self) -&gt; None:
        &#34;&#34;&#34;download and extract file.&#34;&#34;&#34;
        file_url = posixpath.join(self.mirrors, self.resources)
        _urlretrieve(file_url, os.path.join(self.root, self.resources))

    def extract_file(self) -&gt; None:
        &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;
        shutil.unpack_archive(os.path.join(self.root, self.resources), self.root)
        os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.UCMercedLand.classes"><code class="name">var <span class="ident">classes</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.UCMercedLand.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.UCMercedLand.mirrors"><code class="name">var <span class="ident">mirrors</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.UCMercedLand.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.UCMercedLand.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>download and extract file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self) -&gt; None:
    &#34;&#34;&#34;download and extract file.&#34;&#34;&#34;
    file_url = posixpath.join(self.mirrors, self.resources)
    _urlretrieve(file_url, os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.UCMercedLand.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Extract file from compressed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self) -&gt; None:
    &#34;&#34;&#34;Extract file from compressed.&#34;&#34;&#34;
    shutil.unpack_archive(os.path.join(self.root, self.resources), self.root)
    os.remove(os.path.join(self.root, self.resources))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.UCMercedLand.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dataframe type consist of image path and corresponding label.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Return dataframe type consist of image path and corresponding label.&#34;&#34;&#34;
    image_path = []
    label = []
    for cat, enc in self.classes.items():
        cat_path = os.path.join(self.root, &#34;UCMerced_LandUse&#34;, self.data_mode, cat)
        cat_image = [os.path.join(cat_path, path) for path in os.listdir(cat_path)]
        cat_label = [enc] * len(cat_image)
        image_path += cat_image
        label += cat_label
    df = pd.DataFrame({&#34;image&#34;: image_path, &#34;label&#34;: label})

    return df</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="earthvision.datasets.XView"><code class="flex name class">
<span>class <span class="ident">XView</span></span>
<span>(</span><span>root: str, train: bool = True, transform: Optional[Callable] = None, target_transform: Optional[Callable] = None, download: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Dataset from DIUx xView 2018 Detection Challenge.</p>
<p>Source: <a href="https://challenge.xviewdataset.org/data-download">https://challenge.xviewdataset.org/data-download</a> (must login)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong> :&ensp;<code>string</code></dt>
<dd>Root directory of dataset.</dd>
<dt><strong><code>train</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, creates dataset from training set, otherwise
creates from validation set.</dd>
<dt><strong><code>transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that
takes in an PIL image and
returns a transformed version. E.g, transforms.RandomCrop</dd>
<dt><strong><code>target_transform</code></strong> :&ensp;<code>callable</code>, optional</dt>
<dd>A function/transform that takes in the
target and transforms it.</dd>
<dt><strong><code>download</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If true, downloads the dataset from the internet and
puts it in root directory. If dataset is already downloaded, it is not
downloaded again.</dd>
</dl>
<p>Samples at:
- <a href="https://storage.googleapis.com/ossjr/xview/train_images.tgz">https://storage.googleapis.com/ossjr/xview/train_images.tgz</a>
- <a href="https://storage.googleapis.com/ossjr/xview/train_labels.tgz">https://storage.googleapis.com/ossjr/xview/train_labels.tgz</a>
- <a href="https://storage.googleapis.com/ossjr/xview/validation_images.tgz">https://storage.googleapis.com/ossjr/xview/validation_images.tgz</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class XView(VisionDataset):
    &#34;&#34;&#34;Dataset from DIUx xView 2018 Detection Challenge.

    Source: https://challenge.xviewdataset.org/data-download (must login)

    Args:
        root (string): Root directory of dataset.
        train (bool, optional): If True, creates dataset from training set, otherwise
            creates from validation set.
        transform (callable, optional): A function/transform that  takes in an PIL image and
            returns a transformed version. E.g, transforms.RandomCrop
        target_transform (callable, optional): A function/transform that takes in the
            target and transforms it.
        download (bool, optional): If true, downloads the dataset from the internet and
            puts it in root directory. If dataset is already downloaded, it is not
            downloaded again.

    Samples at:
    - https://storage.googleapis.com/ossjr/xview/train_images.tgz
    - https://storage.googleapis.com/ossjr/xview/train_labels.tgz
    - https://storage.googleapis.com/ossjr/xview/validation_images.tgz
    &#34;&#34;&#34;

    urls = []
    resources = [&#34;train_images.tgz&#34;, &#34;train_labels.tgz&#34;, &#34;validation_images.tgz&#34;]

    def __init__(
        self,
        root: str,
        train: bool = True,
        transform: Optional[Callable] = None,
        target_transform: Optional[Callable] = None,
        download: bool = False,
    ) -&gt; None:

        super(XView, self).__init__(root, transform=transform, target_transform=target_transform)

        self.root = root
        self.data_mode = &#34;train&#34; if train else &#34;validation&#34;
        self.class_enc = CLASS_ENC
        self.class_dec = CLASS_DEC
        self.coords, self.chips, self.classes = None, None, None

        if download and self._check_exists():
            print(&#34;file already exists.&#34;)

        if download and not self._check_exists():
            self.download()
            self.extract_file()

        if self.data_mode == &#34;train&#34;:
            self.coords, self.chips, self.classes = self.get_path_and_label()
            self.imgs = list(os.listdir(os.path.join(self.root, &#34;train_images&#34;)))

        elif self.data_mode == &#34;validation&#34;:
            self.imgs = list(os.listdir(os.path.join(self.root, &#34;val_images&#34;)))

    def _check_exists(self) -&gt; bool:

        if not os.path.isdir(self.root):
            os.mkdir(self.root)

        return (
            os.path.exists(os.path.join(self.root, self.resources[0].split(&#34;.&#34;)[0]))
            and os.path.exists(os.path.join(self.root, &#34;xView_train.geojson&#34;))
            if self.data_mode == &#34;train&#34;
            else os.path.exists(os.path.join(self.root, &#34;val_images&#34;))
        )

    def download(self):
        &#34;&#34;&#34;Download file by asking users to input the link&#34;&#34;&#34;
        train_images = input(
            &#34;Please follow the following steps to download the required dataset\n&#34;
            + &#34;1. Visit https://challenge.xviewdataset.org/login\n&#34;
            + &#34;2. Sign up for an account\n&#34;
            + &#34;3. Verify your account\n&#34;
            &#34;4. Follow this link: https://challenge.xviewdataset.org/download-links\n&#34;
            &#34;5. Copy the link for &#39;Download Training Images (tgz)&#39; and paste it: &#34;
        )

        train_labels = input(&#34;\n6. Copy and paste the link for &#39;Download Training Labels (tgz)&#39;: &#34;)

        val_images = input(&#34;\n7. Copy and paste the link for &#39;Download Validation Images (tgz)&#39;: &#34;)

        self.urls = [train_images, train_labels, val_images]

        for idx, url in enumerate(self.urls):
            _urlretrieve(url, os.path.join(self.root, self.resources[idx]))

    def extract_file(self):
        &#34;&#34;&#34;Extract the .tgz file&#34;&#34;&#34;
        for resource in self.resources:
            shutil.unpack_archive(os.path.join(self.root, resource), self.root)
            os.remove(os.path.join(self.root, resource))

    def _check_exists_label(self, filename):
        &#34;&#34;&#34;Check whether bounding boxes, image filenames, and labels
        are already extracted from xView_train.geojson
        &#34;&#34;&#34;
        path_to_check = os.path.join(self.root, filename)
        return path_to_check, os.path.exists(path_to_check)

    def get_path_and_label(self):
        &#34;&#34;&#34;Gets bounding boxes, image filenames, and labels
        from xView_train.geojson

        Returns:
            coords: coordinates of the bounding boxes
            chips: image file names
            classes: classes for each ground truth
        &#34;&#34;&#34;
        # check existnce
        coords_path, coords_exists = self._check_exists_label(&#34;coords.npy&#34;)
        chips_path, chips_exists = self._check_exists_label(&#34;chips.npy&#34;)
        classes_path, classes_exists = self._check_exists_label(&#34;classes.npy&#34;)

        # if exist, load and return
        if coords_exists and chips_exists and classes_exists:
            coords = np.load(coords_path)
            chips = np.load(chips_path)
            classes = np.load(classes_path)
            return coords, chips, classes

        # read xView_train.geojson
        fname = os.path.join(self.root, &#34;xView_train.geojson&#34;)
        with open(fname) as f:
            data = json.load(f)

        # initialize
        coords, chips, classes = [], [], []

        # extract
        feat_len = len(data[&#34;features&#34;])
        img_files = os.listdir(os.path.join(self.root, self.resources[0].split(&#34;.&#34;)[0]))

        for i in range(feat_len):
            properties = data[&#34;features&#34;][i][&#34;properties&#34;]
            b_id = properties[&#34;image_id&#34;]
            val = [int(num) for num in properties[&#34;bounds_imcoords&#34;].split(&#34;,&#34;)]

            # type_id 75 and 82 don&#39;t belong to any class
            # https://github.com/DIUx-xView/xView1_baseline/issues/3
            if properties[&#34;type_id&#34;] not in [75, 82] and b_id in img_files:
                chips.append(b_id)
                classes.append(properties[&#34;type_id&#34;])
                coords.append(val)

        # convert to numpy arrays and save
        coords = np.array(coords)
        chips = np.array(chips)
        classes = np.array(classes)
        np.save(coords_path, coords)
        np.save(chips_path, chips)
        np.save(classes_path, classes)
        return coords, chips, classes

    def __getitem__(self, idx: int) -&gt; Tuple[Any, Any]:
        &#34;&#34;&#34;
        Args:
            idx (int): Index
        Returns:
            tuple: (img, target) where target is a dictionary of target
        consists of bounding boxes and labels.
        &#34;&#34;&#34;
        if self.data_mode == &#34;train&#34;:
            # image
            img_path = os.path.join(self.root, &#34;train_images&#34;, self.chips[idx])
            img = np.array(_load_img(img_path))

            if self.transform is not None:
                img = Image.fromarray(img)
                img = self.transform(img)

            # bounding box
            bbox = self.coords[self.chips == self.chips[idx]]
            # label
            label = self.classes[self.chips == self.chips[idx]]
            label = np.vectorize(index_mapping.get)(label)
            # combine bounding box and label
            target = {}
            target[&#34;boxes&#34;] = bbox
            target[&#34;labels&#34;] = label
            sample = (img, target)

        elif self.data_mode == &#34;validation&#34;:
            # image
            img_path = os.path.join(self.root, &#34;val_images&#34;, self.imgs[idx])
            img = np.array(_load_img(img_path))

            if self.transform is not None:
                img = Image.fromarray(img)
                img = self.transform(img)

            sample = img
        return sample

    def __len__(self) -&gt; int:
        return len(self.imgs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="earthvision.datasets.vision.VisionDataset" href="vision.html#earthvision.datasets.vision.VisionDataset">VisionDataset</a></li>
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="earthvision.datasets.XView.functions"><code class="name">var <span class="ident">functions</span> : Dict[str, Callable]</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.XView.resources"><code class="name">var <span class="ident">resources</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="earthvision.datasets.XView.urls"><code class="name">var <span class="ident">urls</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="earthvision.datasets.XView.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Download file by asking users to input the link</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def download(self):
    &#34;&#34;&#34;Download file by asking users to input the link&#34;&#34;&#34;
    train_images = input(
        &#34;Please follow the following steps to download the required dataset\n&#34;
        + &#34;1. Visit https://challenge.xviewdataset.org/login\n&#34;
        + &#34;2. Sign up for an account\n&#34;
        + &#34;3. Verify your account\n&#34;
        &#34;4. Follow this link: https://challenge.xviewdataset.org/download-links\n&#34;
        &#34;5. Copy the link for &#39;Download Training Images (tgz)&#39; and paste it: &#34;
    )

    train_labels = input(&#34;\n6. Copy and paste the link for &#39;Download Training Labels (tgz)&#39;: &#34;)

    val_images = input(&#34;\n7. Copy and paste the link for &#39;Download Validation Images (tgz)&#39;: &#34;)

    self.urls = [train_images, train_labels, val_images]

    for idx, url in enumerate(self.urls):
        _urlretrieve(url, os.path.join(self.root, self.resources[idx]))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.XView.extract_file"><code class="name flex">
<span>def <span class="ident">extract_file</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Extract the .tgz file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def extract_file(self):
    &#34;&#34;&#34;Extract the .tgz file&#34;&#34;&#34;
    for resource in self.resources:
        shutil.unpack_archive(os.path.join(self.root, resource), self.root)
        os.remove(os.path.join(self.root, resource))</code></pre>
</details>
</dd>
<dt id="earthvision.datasets.XView.get_path_and_label"><code class="name flex">
<span>def <span class="ident">get_path_and_label</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Gets bounding boxes, image filenames, and labels
from xView_train.geojson</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>coords</code></dt>
<dd>coordinates of the bounding boxes</dd>
<dt><code>chips</code></dt>
<dd>image file names</dd>
<dt><code>classes</code></dt>
<dd>classes for each ground truth</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_path_and_label(self):
    &#34;&#34;&#34;Gets bounding boxes, image filenames, and labels
    from xView_train.geojson

    Returns:
        coords: coordinates of the bounding boxes
        chips: image file names
        classes: classes for each ground truth
    &#34;&#34;&#34;
    # check existnce
    coords_path, coords_exists = self._check_exists_label(&#34;coords.npy&#34;)
    chips_path, chips_exists = self._check_exists_label(&#34;chips.npy&#34;)
    classes_path, classes_exists = self._check_exists_label(&#34;classes.npy&#34;)

    # if exist, load and return
    if coords_exists and chips_exists and classes_exists:
        coords = np.load(coords_path)
        chips = np.load(chips_path)
        classes = np.load(classes_path)
        return coords, chips, classes

    # read xView_train.geojson
    fname = os.path.join(self.root, &#34;xView_train.geojson&#34;)
    with open(fname) as f:
        data = json.load(f)

    # initialize
    coords, chips, classes = [], [], []

    # extract
    feat_len = len(data[&#34;features&#34;])
    img_files = os.listdir(os.path.join(self.root, self.resources[0].split(&#34;.&#34;)[0]))

    for i in range(feat_len):
        properties = data[&#34;features&#34;][i][&#34;properties&#34;]
        b_id = properties[&#34;image_id&#34;]
        val = [int(num) for num in properties[&#34;bounds_imcoords&#34;].split(&#34;,&#34;)]

        # type_id 75 and 82 don&#39;t belong to any class
        # https://github.com/DIUx-xView/xView1_baseline/issues/3
        if properties[&#34;type_id&#34;] not in [75, 82] and b_id in img_files:
            chips.append(b_id)
            classes.append(properties[&#34;type_id&#34;])
            coords.append(val)

    # convert to numpy arrays and save
    coords = np.array(coords)
    chips = np.array(chips)
    classes = np.array(classes)
    np.save(coords_path, coords)
    np.save(chips_path, chips)
    np.save(classes_path, classes)
    return coords, chips, classes</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="earthvision" href="../index.html">earthvision</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="earthvision.datasets.aerialcactus" href="aerialcactus.html">earthvision.datasets.aerialcactus</a></code></li>
<li><code><a title="earthvision.datasets.cloud38" href="cloud38.html">earthvision.datasets.cloud38</a></code></li>
<li><code><a title="earthvision.datasets.cowc" href="cowc.html">earthvision.datasets.cowc</a></code></li>
<li><code><a title="earthvision.datasets.deepsat" href="deepsat.html">earthvision.datasets.deepsat</a></code></li>
<li><code><a title="earthvision.datasets.drone_deploy" href="drone_deploy.html">earthvision.datasets.drone_deploy</a></code></li>
<li><code><a title="earthvision.datasets.eurosat" href="eurosat.html">earthvision.datasets.eurosat</a></code></li>
<li><code><a title="earthvision.datasets.l7irish" href="l7irish.html">earthvision.datasets.l7irish</a></code></li>
<li><code><a title="earthvision.datasets.l8biome" href="l8biome.html">earthvision.datasets.l8biome</a></code></li>
<li><code><a title="earthvision.datasets.l8sparcs" href="l8sparcs.html">earthvision.datasets.l8sparcs</a></code></li>
<li><code><a title="earthvision.datasets.landcover" href="landcover.html">earthvision.datasets.landcover</a></code></li>
<li><code><a title="earthvision.datasets.resisc45" href="resisc45.html">earthvision.datasets.resisc45</a></code></li>
<li><code><a title="earthvision.datasets.sentinel2cloud" href="sentinel2cloud.html">earthvision.datasets.sentinel2cloud</a></code></li>
<li><code><a title="earthvision.datasets.so2sat" href="so2sat.html">earthvision.datasets.so2sat</a></code></li>
<li><code><a title="earthvision.datasets.spacenet7" href="spacenet7.html">earthvision.datasets.spacenet7</a></code></li>
<li><code><a title="earthvision.datasets.spacenet7_utils" href="spacenet7_utils.html">earthvision.datasets.spacenet7_utils</a></code></li>
<li><code><a title="earthvision.datasets.ucmercedland" href="ucmercedland.html">earthvision.datasets.ucmercedland</a></code></li>
<li><code><a title="earthvision.datasets.utils" href="utils.html">earthvision.datasets.utils</a></code></li>
<li><code><a title="earthvision.datasets.vision" href="vision.html">earthvision.datasets.vision</a></code></li>
<li><code><a title="earthvision.datasets.xview" href="xview.html">earthvision.datasets.xview</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="earthvision.datasets.AerialCactus" href="#earthvision.datasets.AerialCactus">AerialCactus</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.AerialCactus.download" href="#earthvision.datasets.AerialCactus.download">download</a></code></li>
<li><code><a title="earthvision.datasets.AerialCactus.extract_file" href="#earthvision.datasets.AerialCactus.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.AerialCactus.functions" href="#earthvision.datasets.AerialCactus.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.AerialCactus.get_path_and_label" href="#earthvision.datasets.AerialCactus.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.AerialCactus.mirrors" href="#earthvision.datasets.AerialCactus.mirrors">mirrors</a></code></li>
<li><code><a title="earthvision.datasets.AerialCactus.resources" href="#earthvision.datasets.AerialCactus.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.COWC" href="#earthvision.datasets.COWC">COWC</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.COWC.download" href="#earthvision.datasets.COWC.download">download</a></code></li>
<li><code><a title="earthvision.datasets.COWC.extract_file" href="#earthvision.datasets.COWC.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.COWC.extract_subfile" href="#earthvision.datasets.COWC.extract_subfile">extract_subfile</a></code></li>
<li><code><a title="earthvision.datasets.COWC.functions" href="#earthvision.datasets.COWC.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.COWC.get_path_and_label" href="#earthvision.datasets.COWC.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.COWC.mirrors" href="#earthvision.datasets.COWC.mirrors">mirrors</a></code></li>
<li><code><a title="earthvision.datasets.COWC.resources" href="#earthvision.datasets.COWC.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.Cloud38" href="#earthvision.datasets.Cloud38">Cloud38</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.Cloud38.convert_tif_png" href="#earthvision.datasets.Cloud38.convert_tif_png">convert_tif_png</a></code></li>
<li><code><a title="earthvision.datasets.Cloud38.create_rgb_pil" href="#earthvision.datasets.Cloud38.create_rgb_pil">create_rgb_pil</a></code></li>
<li><code><a title="earthvision.datasets.Cloud38.download" href="#earthvision.datasets.Cloud38.download">download</a></code></li>
<li><code><a title="earthvision.datasets.Cloud38.extract_file" href="#earthvision.datasets.Cloud38.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.Cloud38.file_validator" href="#earthvision.datasets.Cloud38.file_validator">file_validator</a></code></li>
<li><code><a title="earthvision.datasets.Cloud38.functions" href="#earthvision.datasets.Cloud38.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.Cloud38.get_path" href="#earthvision.datasets.Cloud38.get_path">get_path</a></code></li>
<li><code><a title="earthvision.datasets.Cloud38.mirrors" href="#earthvision.datasets.Cloud38.mirrors">mirrors</a></code></li>
<li><code><a title="earthvision.datasets.Cloud38.resources" href="#earthvision.datasets.Cloud38.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.DeepSat" href="#earthvision.datasets.DeepSat">DeepSat</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.DeepSat.choose_data_mode" href="#earthvision.datasets.DeepSat.choose_data_mode">choose_data_mode</a></code></li>
<li><code><a title="earthvision.datasets.DeepSat.dataset_types" href="#earthvision.datasets.DeepSat.dataset_types">dataset_types</a></code></li>
<li><code><a title="earthvision.datasets.DeepSat.download" href="#earthvision.datasets.DeepSat.download">download</a></code></li>
<li><code><a title="earthvision.datasets.DeepSat.functions" href="#earthvision.datasets.DeepSat.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.DeepSat.load_dataset" href="#earthvision.datasets.DeepSat.load_dataset">load_dataset</a></code></li>
<li><code><a title="earthvision.datasets.DeepSat.resources" href="#earthvision.datasets.DeepSat.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.DroneDeploy" href="#earthvision.datasets.DroneDeploy">DroneDeploy</a></code></h4>
<ul class="">
<li><code><a title="earthvision.datasets.DroneDeploy.download" href="#earthvision.datasets.DroneDeploy.download">download</a></code></li>
<li><code><a title="earthvision.datasets.DroneDeploy.functions" href="#earthvision.datasets.DroneDeploy.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.DroneDeploy.load_dataset" href="#earthvision.datasets.DroneDeploy.load_dataset">load_dataset</a></code></li>
<li><code><a title="earthvision.datasets.DroneDeploy.on_epoch_end" href="#earthvision.datasets.DroneDeploy.on_epoch_end">on_epoch_end</a></code></li>
<li><code><a title="earthvision.datasets.DroneDeploy.resources" href="#earthvision.datasets.DroneDeploy.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.EuroSat" href="#earthvision.datasets.EuroSat">EuroSat</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.EuroSat.classes" href="#earthvision.datasets.EuroSat.classes">classes</a></code></li>
<li><code><a title="earthvision.datasets.EuroSat.download" href="#earthvision.datasets.EuroSat.download">download</a></code></li>
<li><code><a title="earthvision.datasets.EuroSat.extract_file" href="#earthvision.datasets.EuroSat.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.EuroSat.functions" href="#earthvision.datasets.EuroSat.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.EuroSat.get_path_and_label" href="#earthvision.datasets.EuroSat.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.EuroSat.mirrors" href="#earthvision.datasets.EuroSat.mirrors">mirrors</a></code></li>
<li><code><a title="earthvision.datasets.EuroSat.resources" href="#earthvision.datasets.EuroSat.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.L7Irish" href="#earthvision.datasets.L7Irish">L7Irish</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.L7Irish.download" href="#earthvision.datasets.L7Irish.download">download</a></code></li>
<li><code><a title="earthvision.datasets.L7Irish.extract_file" href="#earthvision.datasets.L7Irish.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.L7Irish.functions" href="#earthvision.datasets.L7Irish.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.L7Irish.get_download_url" href="#earthvision.datasets.L7Irish.get_download_url">get_download_url</a></code></li>
<li><code><a title="earthvision.datasets.L7Irish.get_path_and_label" href="#earthvision.datasets.L7Irish.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.L7Irish.mirrors" href="#earthvision.datasets.L7Irish.mirrors">mirrors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.L8Biome" href="#earthvision.datasets.L8Biome">L8Biome</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.L8Biome.download" href="#earthvision.datasets.L8Biome.download">download</a></code></li>
<li><code><a title="earthvision.datasets.L8Biome.extract_file" href="#earthvision.datasets.L8Biome.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.L8Biome.functions" href="#earthvision.datasets.L8Biome.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.L8Biome.get_download_url" href="#earthvision.datasets.L8Biome.get_download_url">get_download_url</a></code></li>
<li><code><a title="earthvision.datasets.L8Biome.get_path_and_label" href="#earthvision.datasets.L8Biome.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.L8Biome.mirrors" href="#earthvision.datasets.L8Biome.mirrors">mirrors</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.L8SPARCS" href="#earthvision.datasets.L8SPARCS">L8SPARCS</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.L8SPARCS.download" href="#earthvision.datasets.L8SPARCS.download">download</a></code></li>
<li><code><a title="earthvision.datasets.L8SPARCS.extract_file" href="#earthvision.datasets.L8SPARCS.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.L8SPARCS.functions" href="#earthvision.datasets.L8SPARCS.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.L8SPARCS.get_path_and_label" href="#earthvision.datasets.L8SPARCS.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.L8SPARCS.mirrors" href="#earthvision.datasets.L8SPARCS.mirrors">mirrors</a></code></li>
<li><code><a title="earthvision.datasets.L8SPARCS.resources" href="#earthvision.datasets.L8SPARCS.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.LandCover" href="#earthvision.datasets.LandCover">LandCover</a></code></h4>
<ul class="">
<li><code><a title="earthvision.datasets.LandCover.download" href="#earthvision.datasets.LandCover.download">download</a></code></li>
<li><code><a title="earthvision.datasets.LandCover.extract_file" href="#earthvision.datasets.LandCover.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.LandCover.functions" href="#earthvision.datasets.LandCover.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.LandCover.get_image_path_and_mask_path" href="#earthvision.datasets.LandCover.get_image_path_and_mask_path">get_image_path_and_mask_path</a></code></li>
<li><code><a title="earthvision.datasets.LandCover.mirrors" href="#earthvision.datasets.LandCover.mirrors">mirrors</a></code></li>
<li><code><a title="earthvision.datasets.LandCover.resources" href="#earthvision.datasets.LandCover.resources">resources</a></code></li>
<li><code><a title="earthvision.datasets.LandCover.to_chip_img_mask" href="#earthvision.datasets.LandCover.to_chip_img_mask">to_chip_img_mask</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.RESISC45" href="#earthvision.datasets.RESISC45">RESISC45</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.RESISC45.download" href="#earthvision.datasets.RESISC45.download">download</a></code></li>
<li><code><a title="earthvision.datasets.RESISC45.extract_file" href="#earthvision.datasets.RESISC45.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.RESISC45.functions" href="#earthvision.datasets.RESISC45.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.RESISC45.get_path_and_label" href="#earthvision.datasets.RESISC45.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.RESISC45.mirrors" href="#earthvision.datasets.RESISC45.mirrors">mirrors</a></code></li>
<li><code><a title="earthvision.datasets.RESISC45.resources" href="#earthvision.datasets.RESISC45.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.Sentinel2Cloud" href="#earthvision.datasets.Sentinel2Cloud">Sentinel2Cloud</a></code></h4>
<ul class="">
<li><code><a title="earthvision.datasets.Sentinel2Cloud.download" href="#earthvision.datasets.Sentinel2Cloud.download">download</a></code></li>
<li><code><a title="earthvision.datasets.Sentinel2Cloud.extract_file" href="#earthvision.datasets.Sentinel2Cloud.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.Sentinel2Cloud.functions" href="#earthvision.datasets.Sentinel2Cloud.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.Sentinel2Cloud.get_image_path_and_mask_path" href="#earthvision.datasets.Sentinel2Cloud.get_image_path_and_mask_path">get_image_path_and_mask_path</a></code></li>
<li><code><a title="earthvision.datasets.Sentinel2Cloud.mask_resources" href="#earthvision.datasets.Sentinel2Cloud.mask_resources">mask_resources</a></code></li>
<li><code><a title="earthvision.datasets.Sentinel2Cloud.mirrors" href="#earthvision.datasets.Sentinel2Cloud.mirrors">mirrors</a></code></li>
<li><code><a title="earthvision.datasets.Sentinel2Cloud.resources" href="#earthvision.datasets.Sentinel2Cloud.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.So2Sat" href="#earthvision.datasets.So2Sat">So2Sat</a></code></h4>
<ul class="">
<li><code><a title="earthvision.datasets.So2Sat.download" href="#earthvision.datasets.So2Sat.download">download</a></code></li>
<li><code><a title="earthvision.datasets.So2Sat.functions" href="#earthvision.datasets.So2Sat.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.So2Sat.get_path_and_label" href="#earthvision.datasets.So2Sat.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.So2Sat.mirrors" href="#earthvision.datasets.So2Sat.mirrors">mirrors</a></code></li>
<li><code><a title="earthvision.datasets.So2Sat.resources" href="#earthvision.datasets.So2Sat.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.SpaceNet7" href="#earthvision.datasets.SpaceNet7">SpaceNet7</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.SpaceNet7.download" href="#earthvision.datasets.SpaceNet7.download">download</a></code></li>
<li><code><a title="earthvision.datasets.SpaceNet7.extract_file" href="#earthvision.datasets.SpaceNet7.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.SpaceNet7.functions" href="#earthvision.datasets.SpaceNet7.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.SpaceNet7.generate_mask" href="#earthvision.datasets.SpaceNet7.generate_mask">generate_mask</a></code></li>
<li><code><a title="earthvision.datasets.SpaceNet7.get_path_and_label" href="#earthvision.datasets.SpaceNet7.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.SpaceNet7.resources" href="#earthvision.datasets.SpaceNet7.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.UCMercedLand" href="#earthvision.datasets.UCMercedLand">UCMercedLand</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.UCMercedLand.classes" href="#earthvision.datasets.UCMercedLand.classes">classes</a></code></li>
<li><code><a title="earthvision.datasets.UCMercedLand.download" href="#earthvision.datasets.UCMercedLand.download">download</a></code></li>
<li><code><a title="earthvision.datasets.UCMercedLand.extract_file" href="#earthvision.datasets.UCMercedLand.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.UCMercedLand.functions" href="#earthvision.datasets.UCMercedLand.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.UCMercedLand.get_path_and_label" href="#earthvision.datasets.UCMercedLand.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.UCMercedLand.mirrors" href="#earthvision.datasets.UCMercedLand.mirrors">mirrors</a></code></li>
<li><code><a title="earthvision.datasets.UCMercedLand.resources" href="#earthvision.datasets.UCMercedLand.resources">resources</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="earthvision.datasets.XView" href="#earthvision.datasets.XView">XView</a></code></h4>
<ul class="two-column">
<li><code><a title="earthvision.datasets.XView.download" href="#earthvision.datasets.XView.download">download</a></code></li>
<li><code><a title="earthvision.datasets.XView.extract_file" href="#earthvision.datasets.XView.extract_file">extract_file</a></code></li>
<li><code><a title="earthvision.datasets.XView.functions" href="#earthvision.datasets.XView.functions">functions</a></code></li>
<li><code><a title="earthvision.datasets.XView.get_path_and_label" href="#earthvision.datasets.XView.get_path_and_label">get_path_and_label</a></code></li>
<li><code><a title="earthvision.datasets.XView.resources" href="#earthvision.datasets.XView.resources">resources</a></code></li>
<li><code><a title="earthvision.datasets.XView.urls" href="#earthvision.datasets.XView.urls">urls</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>